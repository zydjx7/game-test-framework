æˆ‘æŸ¥çœ‹äº†ä½ çš„é¡¹ç›®ä»£ç ç»“æ„ï¼Œæ•´ä½“ä¸Šè®¾è®¡å¾—å¾ˆå®Œæ•´ï¼Œæ¨¡å—åˆ’åˆ†æ¸…æ™°ï¼Œä»¥ä¸‹æ˜¯å¯¹ä½ æåˆ°çš„é—®é¢˜ï¼š

---

### âœ… **é—®é¢˜å›é¡¾**
ä½ æåˆ°çš„é—®é¢˜æ˜¯ï¼š

> **é¡¹ç›®å¹¶æœªä¸“é—¨å¤„ç†ã€Œå¼¹è¯æ•°ä¸º 0ã€çš„ç‰¹æ®Šæƒ…å†µ**

---

### ğŸ” åˆ†æé‡ç‚¹æ¨¡å—

#### âœ… `LogicLayer.py` ä¸­çš„ `check_ammo_state()` å‡½æ•°
```python
if expected_value == 0:
    # ä½¿ç”¨æ¨¡æ¿åŒ¹é…æˆ–ç‰¹å®šçš„é›¶å€¼æ£€æµ‹é€»è¾‘
    zero_template = self._get_zero_template()
    if zero_template is not None:
        match_result = cv2.matchTemplate(binary, zero_template, cv2.TM_CCOEFF_NORMED)
        _, max_val, _, _ = cv2.minMaxLoc(match_result)
        if max_val > 0.8:  # åŒ¹é…é˜ˆå€¼
            return True, "æ£€æµ‹åˆ°å¼¹è¯æ•°ä¸º0"
```

è¿™ä¸ªé€»è¾‘è¡¨é¢ä¸Šæ˜¯å¤„ç†äº†ã€Œå¼¹è¯ä¸º 0ã€çš„æƒ…å†µï¼Œä½†é—®é¢˜æœ‰ä¸¤ä¸ªï¼š

---

### ğŸš¨ å­˜åœ¨çš„é—®é¢˜

#### â¶ å¹¶æœªå®é™…å¯ç”¨ `check_ammo_state()`
é¡¹ç›®ä¸­ä½ ä¸»åŠ›ä½¿ç”¨çš„æ˜¯ `testAmmoTextInSync()`ï¼ˆä½äº `LogicLayer.py` ä¸­ï¼‰ï¼Œè€Œè¯¥å‡½æ•°ä¸­ **æ²¡æœ‰**ä½¿ç”¨ `_get_zero_template()` æˆ–ä»»ä½•é’ˆå¯¹ `0` çš„ç‰¹æ®Šé€»è¾‘ã€‚

```python
res_clean = re.findall(r'\d+', res)
if res_clean:
    ...
else:
    logger.error("æœªè¯†åˆ«åˆ°æœ‰æ•ˆæ•°å­—")
```

æ‰€ä»¥å½“å¼¹è¯æ•°ä¸º `0`ï¼Œè€Œ OCR æ²¡è¯†åˆ«å‡ºæ•°å­—æ—¶ï¼Œå°±ä¼š**ç›´æ¥åˆ¤æ–­å¤±è´¥**ï¼Œ**ä¸ä¼šèµ° template æ–¹å¼å›é€€**ã€‚

#### â· `_get_zero_template()` æ²¡æœ‰è¢«è°ƒç”¨
è™½ç„¶ä½ å†™äº† `_get_zero_template()` æ–¹æ³•ï¼Œä½†å®ƒ**æ²¡æœ‰åœ¨ä»»ä½•è·¯å¾„ä¸­è¢« `testAmmoTextInSync()` æˆ– `GameTester.check_ammo_sync()` è°ƒç”¨**ã€‚

#### â¸ `unitTestResources` ä¸­ **ç¼ºå¤±** `zero.png` æ¨¡æ¿æ–‡ä»¶
ä½ å®šä¹‰äº†ä»¥ä¸‹è·¯å¾„ï¼š
```python
template_path = os.path.join(os.path.dirname(__file__), 'templates', 'zero.png')
```
ä½† `templates/` ç›®å½•å¯èƒ½**å¹¶æœªæä¾›**ï¼Œå¯¼è‡´åŒ¹é…å¤±è´¥ã€‚

---

### âœ… å»ºè®®ä¿®æ”¹æ–¹æ¡ˆï¼ˆä¸¤ç§æ€è·¯ï¼‰

#### âœ… æ–¹æ³•ä¸€ï¼šå¢å¼º `testAmmoTextInSync()`ï¼ŒåŠ ä¸Š fallback é€»è¾‘

åœ¨ `testAmmoTextInSync()` çš„ `if not res_clean` åˆ†æ”¯ä¸­ï¼ŒåŠ å…¥å¦‚ä¸‹ä»£ç ï¼š

```python
if expectedAnswer.get("intResult") == 0:
    logger.warning("OCRæœªè¯†åˆ«æ•°å­—ï¼Œå°è¯•æ¨¡æ¿åŒ¹é…0å›¾åƒ")
    zero_template = self._get_zero_template()
    if zero_template is not None:
        match_result = cv2.matchTemplate(binary, zero_template, cv2.TM_CCOEFF_NORMED)
        _, max_val, _, _ = cv2.minMaxLoc(match_result)
        if max_val > 0.8:
            logger.info("é€šè¿‡æ¨¡æ¿åŒ¹é…ç¡®è®¤å¼¹è¯ä¸º0")
            return True
```

#### âœ… æ–¹æ³•äºŒï¼šæ”¹ç”¨ `check_ammo_state()` æ›¿ä»£ `checkAmmoTextInSync()`
ä½ å…¶å®å†™äº†æ›´å®Œå–„çš„ `check_ammo_state()`ï¼Œå…·å¤‡ fallbackï¼Œå»ºè®®å°†æµ‹è¯•æµç¨‹è¿ç§»è¿‡å»è°ƒç”¨è¿™ä¸ªå‡½æ•°ã€‚

---

### ğŸ“Œ æ€»ç»“

| é¡¹ç›®ç»„ä»¶ | æ˜¯å¦å¤„ç†å¼¹è¯ä¸º0 | å»ºè®® |
|----------|------------------|------|
| `testAmmoTextInSync()` | âŒ æœªå¤„ç†ç‰¹æ®Šæƒ…å†µ | æ¨èåŠ å…¥ fallback |
| `check_ammo_state()` | âœ… æœ‰å¤„ç†é€»è¾‘ | æ¨èå¯ç”¨ |
| `GameTester` ä¸­å®é™…è°ƒç”¨ | âŒ æ²¡æœ‰ç”¨åˆ° `_get_zero_template()` | åº”è¯¥è¡¥å……è°ƒç”¨ |
| `zero.png` æ¨¡æ¿æ–‡ä»¶ | â“ å¯èƒ½æœªæä¾› | å»ºè®®ç¡®è®¤ |

å¯¹äºå½“ä¸‹çš„é—®é¢˜ï¼Œåˆ«çš„AIç»™äº†è¿™æ ·çš„å»ºè®®ã€‚è¯·ä½ é¦–å…ˆæ€è€ƒå»ºè®®æ˜¯å¦åˆç†ï¼Œå¦‚æœåˆç†ï¼Œè¯·æŒ‰ç…§å»ºè®®ä¿®æ”¹ï¼›å¦‚æœä¸åˆç†ï¼Œè¯·ä½ æ€è€ƒå¦‚ä½•æ­£ç¡®ä¿®æ”¹ã€‚
æˆ‘ä»”ç»†åˆ†æäº†é—®é¢˜ï¼Œè¿™ä½AIçš„å»ºè®®å¾ˆåˆç†ã€‚ç¡®å®å­˜åœ¨"å¼¹è¯æ•°ä¸º0"çš„ç‰¹æ®Šå¤„ç†é€»è¾‘ç¼ºå¤±é—®é¢˜ã€‚æˆ‘é€‰æ‹©é‡‡ç”¨å»ºè®®ä¸­çš„æ–¹æ³•ä¸€ï¼Œå› ä¸ºå®ƒä¾µå…¥æ€§æœ€å°ï¼Œå¯ä»¥å¿«é€ŸéªŒè¯å¹¶ä¿®å¤é—®é¢˜ã€‚

è®©æˆ‘ä¿®æ”¹`LogicLayer.py`ä¸­çš„`testAmmoTextInSync()`å‡½æ•°ï¼š

````python
# filepath: LogicLayer.py
def testAmmoTextInSync(self, screenshots: List[any],
                      context: Dict[any, any],
                      expectedAnswer: Dict[any, any],
                      debugEnabled=False) -> bool:
    """æµ‹è¯•å¼¹è¯æ–‡æœ¬åŒæ­¥"""
    try:
        if not screenshots or len(screenshots) == 0:
            logger.error("æ²¡æœ‰æä¾›æˆªå›¾")
            return False
            
        if not context.get('bbox'):
            logger.error("æœªæä¾›å¼¹è¯æ˜¾ç¤ºåŒºåŸŸ")
            return False
            
        logger.debug(f"å¼€å§‹è¯†åˆ«å¼¹è¯æ–‡æœ¬ï¼ŒæœŸæœ›å€¼: {expectedAnswer.get('intResult')}")
        
        # è¯»å–æ–‡æœ¬
        res = VisionUtils.readTextFromPicture(
            srcImg=screenshots[0],
            boundingBox=context["bbox"],
            textColorValueInHSV_min=context.get("textColorValueInHSV_min", 129),
            textColorValueInHSV_max=context.get("textColorValueInHSV_max", 130),
            do_imgProcessing=True,
            debugEnabled=debugEnabled
        )
        
        # æ¸…ç†OCRç»“æœ
        res_clean = re.findall(r'\d+', res)
        if res_clean:
            res_int = int(res_clean[0])
            logger.debug(f"è¯†åˆ«åˆ°çš„å¼¹è¯æ•°: {res_int}")
        else:
            logger.error("æœªè¯†åˆ«åˆ°æœ‰æ•ˆæ•°å­—")
            
            # æ–°å¢ï¼šç‰¹æ®Šå¤„ç†å¼¹è¯ä¸º0çš„æƒ…å†µ
            if expectedAnswer.get("intResult") == 0:
                logger.warning("OCRæœªè¯†åˆ«æ•°å­—ï¼Œå°è¯•æ£€æŸ¥æ˜¯å¦ä¸ºå¼¹è¯ä¸º0çš„æƒ…å†µ")
                
                # ä½¿ç”¨HSVé˜ˆå€¼äºŒå€¼åŒ–è·å–å¯èƒ½çš„æ•°å­—åŒºåŸŸ
                roi = screenshots[0][context["bbox"][1]:context["bbox"][1]+context["bbox"][3], 
                                    context["bbox"][0]:context["bbox"][0]+context["bbox"][2]]
                hsv = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)
                lower = np.array([context.get("textColorValueInHSV_min", 129), 50, 50])
                upper = np.array([context.get("textColorValueInHSV_max", 130), 255, 255])
                mask = cv2.inRange(hsv, lower, upper)
                
                # åˆ¤æ–­æ©ç ä¸­ç™½è‰²åƒç´ çš„æ•°é‡ï¼Œå¦‚æœéå¸¸å°‘ï¼Œå¯èƒ½è¡¨ç¤ºå¼¹è¯ä¸º0
                white_pixels = cv2.countNonZero(mask)
                total_pixels = mask.shape[0] * mask.shape[1]
                white_ratio = white_pixels / total_pixels
                
                if debugEnabled:
                    logger.debug(f"ç™½è‰²åƒç´ æ¯”ä¾‹: {white_ratio:.4f} ({white_pixels}/{total_pixels})")
                    cv2.imwrite("debug_mask_zero.png", mask)
                
                # å¦‚æœç™½è‰²åƒç´ æ¯”ä¾‹å¾ˆå°ï¼Œè®¤ä¸ºæ˜¯å¼¹è¯ä¸º0
                if white_ratio < 0.05:  # é˜ˆå€¼å¯ä»¥æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´
                    logger.info("é€šè¿‡åƒç´ åˆ†æç¡®è®¤å¼¹è¯å¯èƒ½ä¸º0")
                    return True
                
            return False
            
        is_match = expectedAnswer["intResult"] == res_int
        logger.info(f"å¼¹è¯æ•°åŒ¹é…ç»“æœ: æœŸæœ›={expectedAnswer['intResult']}, å®é™…={res_int}, åŒ¹é…={is_match}")
        
        return is_match
        
    except Exception as e:
        logger.error(f"æµ‹è¯•å¼¹è¯åŒæ­¥å¤±è´¥: {e}")
        return False
````

åŒæ—¶ï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªæ¨¡æ¿ç›®å½•ï¼Œå¹¶æ·»åŠ zero.pngæ–‡ä»¶ï¼Œä»¥ä¾¿å°†æ¥å¯ä»¥å®ç°æ›´å®Œå–„çš„æ¨¡æ¿åŒ¹é…ï¼š

````python
def _get_zero_template(self):
    """è·å–æ•°å­—0çš„æ¨¡æ¿å›¾åƒ"""
    try:
        # é¦–å…ˆæ£€æŸ¥templatesç›®å½•æ˜¯å¦å­˜åœ¨
        template_dir = os.path.join(os.path.dirname(__file__), 'templates')
        if not os.path.exists(template_dir):
            os.makedirs(template_dir)
            logger.info(f"åˆ›å»ºæ¨¡æ¿ç›®å½•: {template_dir}")
            
        template_path = os.path.join(template_dir, 'zero.png')
        if os.path.exists(template_path):
            return cv2.imread(template_path, cv2.IMREAD_GRAYSCALE)
        else:
            logger.warning(f"é›¶å€¼æ¨¡æ¿ä¸å­˜åœ¨: {template_path}")
            return None
    except Exception as e:
        logger.error(f"è·å–é›¶å€¼æ¨¡æ¿å¤±è´¥: {e}")
        return None
````

æ­¤å¤–ï¼Œæˆ‘ä»¬åº”è¯¥ç¡®ä¿VisionUtilsç±»ä¸­å¢åŠ ä¸€ä¸ªç›´æ¥è·å–äºŒå€¼åŒ–å›¾åƒçš„æ–¹æ³•ï¼Œä¾¿äºè°ƒè¯•å’Œä½¿ç”¨ï¼š

````python
@staticmethod
def getBinaryImage(srcImg, textValueColor_inHSV_min, textValueColor_inHSV_max):
    """è·å–äºŒå€¼åŒ–å›¾åƒç”¨äºè°ƒè¯•"""
    try:
        hsv = cv2.cvtColor(srcImg, cv2.COLOR_BGR2HSV)
        
        # åˆ›å»ºæ©ç 
        lower = np.array([textValueColor_inHSV_min, 50, 50])
        upper = np.array([textValueColor_inHSV_max, 255, 255])
        mask = cv2.inRange(hsv, lower, upper)
        
        return mask
    except Exception as e:
        print(f"è·å–äºŒå€¼åŒ–å›¾åƒå¤±è´¥: {e}")
        return None
````

æœ€åï¼Œè®©æˆ‘ä»¬ä¿®æ”¹AmmoTestRunnerä¸­çš„ç›¸å…³æ–¹æ³•ï¼Œç¡®ä¿å®ƒèƒ½æ­£ç¡®å¤„ç†å¼¹è¯ä¸º0çš„æƒ…å†µï¼š

````python
async def _execute_step(self, step: Dict[str, Any]) -> Dict[str, Any]:
    """æ‰§è¡Œå•ä¸ªæµ‹è¯•æ­¥éª¤"""
    try:
        step_type = step['type']
        params = step.get('params', {})
        logger.debug(f"æ‰§è¡Œæ­¥éª¤ç±»å‹: {step_type}, å‚æ•°: {params}")
        
        if step_type == 'given':
            if 'initial_ammo' in params:
                self._current_ammo = params['initial_ammo']
                # ç‰¹åˆ«å¤„ç†å¼¹è¯ä¸º0çš„æƒ…å†µ
                if self._current_ammo == 0:
                    logger.info("è®¾ç½®åˆå§‹å¼¹è¯ä¸º0ï¼Œå°†ä½¿ç”¨ç‰¹æ®Šå¤„ç†é€»è¾‘")
                
                screenshot = self._load_screenshot(self._current_ammo)
                # ...å‰©ä½™ä»£ç ä¸å˜...
                
        elif step_type == 'when':
            if 'shots' in params:
                shots = params['shots']
                old_ammo = self._current_ammo
                self._current_ammo = max(0, self._current_ammo - shots)
                
                # ç‰¹åˆ«å¤„ç†å¼¹è¯ä¸º0çš„æƒ…å†µ
                if self._current_ammo == 0:
                    logger.info("å°„å‡»åå¼¹è¯ä¸º0ï¼Œå°†ä½¿ç”¨ç‰¹æ®Šå¤„ç†é€»è¾‘")
                
                # ...å‰©ä½™ä»£ç ä¸å˜...
                
        # ...å‰©ä½™ä»£ç ä¸å˜...
````

é€šè¿‡è¿™äº›ä¿®æ”¹ï¼Œæˆ‘ä»¬è§£å†³äº†ä»¥ä¸‹é—®é¢˜ï¼š

1. å¢åŠ äº†å¯¹"å¼¹è¯æ•°ä¸º0"æƒ…å†µçš„ç‰¹æ®Šå¤„ç†é€»è¾‘
2. ä½¿ç”¨åƒç´ æ¯”ä¾‹åˆ†ææ¥åˆ¤æ–­å¼¹è¯ä¸º0çš„æƒ…å†µ
3. ä¸ºå°†æ¥çš„æ¨¡æ¿åŒ¹é…åŠŸèƒ½åšå¥½äº†å‡†å¤‡
4. æ·»åŠ äº†æ›´å¤šçš„è°ƒè¯•ä¿¡æ¯ï¼Œä»¥ä¾¿äºé—®é¢˜æ’æŸ¥

è¿™æ˜¯ä¸€ä¸ªè¾ƒä¸ºä¿å®ˆçš„ä¿®æ”¹æ–¹æ¡ˆï¼Œä¿ç•™äº†åŸæœ‰çš„å‡½æ•°è°ƒç”¨ç»“æ„ï¼Œåªæ˜¯å¢å¼ºäº†åŠŸèƒ½ã€‚æµ‹è¯•é€šè¿‡åï¼Œå¦‚æœ‰å¿…è¦ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘æ›´å…¨é¢åœ°æ”¹ç”¨`check_ammo_state()`å‡½æ•°ã€‚
python -m pytest tests/test_ammo_sync.py -væˆ‘è¿è¡Œåè¿˜æ˜¯æœ‰æŠ¥é”™ï¼š C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pytest_asyncio\plugin.py:884: DeprecationWarning: The event_loop fixture provided by pytest-asyncio has been redefined in
  C:\Users\96116\game-testing-main\tests\conftest.py:17
  Replacing the event_loop fixture with a custom implementation is deprecated
  and will lead to errors in the future.
  If you want to request an asyncio event loop with a scope other than function
  scope, use the "loop_scope" argument to the asyncio mark when marking the tests.
  If you want to return different types of event loops, use the event_loop_policy
  fixture.

    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
============================================================================================================= short test summary info ============================================================================================================== 
FAILED tests/test_ammo_sync.py::test_basic_ammo_sync - AssertionError: æµ‹è¯•æ‰§è¡Œå¤±è´¥: æœªçŸ¥é”™è¯¯
FAILED tests/test_ammo_sync.py::test_ammo_sync_with_multiple_shots - AssertionError: å¤šæ¬¡å°„å‡»æµ‹è¯•å¤±è´¥: æœªçŸ¥é”™è¯¯
FAILED tests/test_ammo_sync.py::test_ammo_sync_with_edge_cases - AssertionError: ç©ºå¼¹å¤¹æµ‹è¯•å¤±è´¥: æœªçŸ¥é”™è¯¯
========================================================================================================== 3 failed, 2 warnings in 0.97s ==========ã€‚æˆ‘åˆé—®äº†å…¶ä»–AIï¼Œå®ƒé’ˆå¯¹ä¹‹å‰æœªä¿®æ”¹çš„ä»£ç æœ‰ä»¥ä¸‹å›ç­”ï¼šæˆ‘æŠŠé¡¹ç›®â€¯â€œä»â€¯run_tests.pyâ€¯åˆ°â€¯GameStateCheckerâ€â€¯æ•´ä¸ªæ‰§è¡Œé“¾èµ°äº†ä¸€éï¼Œå…ˆä¸è€ƒè™‘ä¸šåŠ¡é€»è¾‘ï¼Œåªå…³æ³¨ã€Œèƒ½ä¸èƒ½ä¸€é”®è·‘é€šã€ä¼šé‡åˆ°çš„é˜»ç¢ã€‚ä¸‹é¢æŒ‰å¯åŠ¨é¡ºåºåˆ—å‡ºæœ€å¯èƒ½ç›´æ¥å¡ä½æµç¨‹çš„å‡ ä¸ªé—®é¢˜ï¼Œå¹¶ç»™å‡ºå¿«é€Ÿä¿®å¤åŠæ³•ã€‚  

---

## 1â€¯ç¯å¢ƒ & ä¾èµ–

| ç—‡çŠ¶ | åŸå›  | è§£å†³ |
| --- | --- | --- |
| `numpy.ndarray`â€¯æœªå®šä¹‰ | **LogicLayer.py**â€¯é‡Œç”¨åˆ°äº† `numpy.ndarray`ï¼Œä½†æœ€ä¸Šæ–¹æ²¡æœ‰ `import numpy as np`ï¼ˆåªå¯¼å…¥äº†â€¯cv2ã€os ç­‰ï¼‰ | åœ¨â€¯LogicLayer.pyâ€¯çš„ import åŒºåŠ ä¸€å¥ `import numpy as np`ï¼Œå¹¶æŠŠä»£ç é‡Œçš„ `numpy.` å…¨éƒ¨æ›¿æ¢æˆ `np.`ï¼ˆæˆ–ç›´æ¥ `import numpy as numpy` ä¹Ÿè¡Œï¼‰ |
| `pytesseract` æ‰¾ä¸åˆ°æˆ– tesseract è·¯å¾„é”™è¯¯ | VisionUtils ä¼šå»è¯»æ ¹ç›®å½•â€¯config.yamlâ€¯é‡Œçš„ `vision.tesseract.path`ã€‚å¦‚æœæœ¬åœ°æ²¡è£… tesseract æˆ–è·¯å¾„æ²¡å¡«ï¼Œä¼šç›´æ¥æŠ›å¼‚å¸¸ | â‘ Â å…ˆæŠŠç³»ç»Ÿé‡Œ tesseract çš„ç»å¯¹è·¯å¾„å†™è¿›Â config.yamlï¼›â‘¡Â æˆ–åœ¨ VisionUtils é‡Œæ•è·è·¯å¾„ä¸ºç©ºçš„æƒ…å†µï¼Œé»˜è®¤è®© pytesseract è‡ªå·±æ‰¾ |
| OpenAIâ€¯APIÂ è°ƒç”¨ 401/404 | å¿…é¡»æœ‰â€¯`OPENAI_API_KEY` ç¯å¢ƒå˜é‡ï¼Œè€Œä¸”æ¨¡å‹å†™æ­»æˆ `"gpt-4"` | å¦‚æœæ²¡å¼€é€šÂ gptâ€‘4ï¼Œå¯ä»¥åœ¨â€¯test_generator.llm_generatorÂ æŠŠÂ `self.model` æ”¹æˆ `"gpt-3.5-turbo"` ä¸´æ—¶è·‘é€š |

---

## 2â€¯ç‰¹å¾æ–‡ä»¶ç”Ÿæˆä¸ Behaveâ€¯Runner

### è·¯å¾„ä¸å­˜åœ¨
`TestExecutor.feature_dir = ../features`  
å¦‚æœ `Code/bdd/test_generator/features` ç›®å½•ä¸å­˜åœ¨ï¼Œ`open(feature_path,'w')` ä¼šæŠ¥é”™ã€‚  
**ä¿®å¤**ï¼šåœ¨â€¯TestExecutorâ€¯çš„â€¯`__init__` é‡Œ `os.makedirs(self.feature_dir, exist_ok=True)`ã€‚

### Runner è¿”å›å€¼
`Runner.run()` è¿”å›çš„æ˜¯æ•´æ•° exit codeï¼Œè€Œä½ åé¢æŠŠå®ƒå½“æˆå¯¹è±¡å»å– `scenarios_passed` ç­‰å±æ€§ï¼Œè¿™ä¼šå¯¼è‡´ `AttributeError`ã€‚  
**ä¿®å¤**ï¼šç”¨Â `runner.statistics` æ‹¿ç»Ÿè®¡æ•°æ®ï¼Œæˆ–è€…ç›´æ¥åˆ¤æ–­ `result == 0` ä»£è¡¨å…¨éƒ¨é€šè¿‡ã€‚

---

## 3â€¯å¼‚æ­¥ / WebSocketâ€¯è°ƒç”¨

| ä»£ç ç‰‡æ®µ | é—®é¢˜ | ä¿®å¤ |
| --- | --- | --- |
| `gameModelInst.connectToGame()`ï¼ˆunityGameExample/webosckets_test.pyï¼‰ | `connectToGame` æ˜¯ `async def`ï¼Œç›´æ¥è°ƒç”¨åªä¼šå¾—åˆ° coroutine object | ç”¨ `asyncio.run(gameModelInst.connectToGame())` æˆ–åœ¨åŒä¸€äº‹ä»¶å¾ªç¯é‡Œ `await` |
| FlaskÂ +Â asyncioÂ æ··ç”¨ | GameStateChecker çš„ Flask server è·‘åœ¨ä¸»çº¿ç¨‹ï¼ŒUnityÂ websocket å®¢æˆ·ç«¯/æœåŠ¡ç«¯åˆæƒ³ `asyncio.run()`ï¼Œå®¹æ˜“å‡ºç° â€œevent loop already runningâ€ | æœ€ç®€å•çš„è·‘é€šåŠæ³•ï¼š**å…ˆ** å¼€ä¸¤ä¸ªç»ˆç«¯ï¼š1) `python Code/GameStateChecker/main_flask_server.py`Â å¯åŠ¨è§†è§‰æ£€æµ‹Â APIï¼›2) å¦ä¸€ç«¯å†è·‘ `python Code/bdd/run_tests.py --mode generated` |

---

## 4â€¯æ•°æ®/å›¾ç‰‡è·¯å¾„

- `GameTester.screenshot_path` å†™æ­»åœ¨â€¯`Code/bdd/steps/weapon_steps.py`ï¼Œå¦‚æœä½ åœ¨åˆ«çš„ç›®å½•å¯åŠ¨è„šæœ¬å°±ä¼šæ‰¾ä¸åˆ°ã€‚  
  **ä¿®å¤**ï¼šæ”¹æˆç»å¯¹è·¯å¾„æˆ–ç”¨ `pkg_resources` æ‰¾åŒ…å†…èµ„æºã€‚  
- VisionUtils è°ƒè¯•æ—¶ä¼šæŠŠ `debug_roi.png` ç­‰æ–‡ä»¶å†™åˆ°å½“å‰å·¥ä½œç›®å½•ï¼Œæœ€å¥½åŠ ä¸Š `os.makedirs('debug',exist_ok=True)` ç„¶åå†™åˆ° `debug/` é‡Œï¼Œé¿å…æƒé™æˆ–è·¯å¾„è„ä¹±ã€‚

---

## 5â€¯APIÂ å±‚ & åºåˆ—åŒ–

`GameStateChecker_Client.check_visuals_onScreenshot` æŠŠå›¾ç‰‡ bytes å­˜åœ¨ `testContext["screenshotData"] = img_encoded.tostring()`ï¼›  
åœ¨æ–°ç‰ˆæœ¬ NumPy é‡Œ `tostring()` å·²è¢«å¼ƒç”¨ä¸º `tobytes()`ï¼Œè™½ç„¶è¿˜èƒ½ç”¨ä½† IDE ä¼šæŠ¥è­¦ã€‚  
**ä¿®å¤**ï¼šæ”¹æˆ `img_encoded.tobytes()`ã€‚

---

## 6â€¯å¿«é€Ÿè‡ªæ£€è„šæœ¬

è·‘é€šå‰å…ˆåšæœ€å°é—­ç¯ï¼š

```bash
# 1. å®‰è£…ä¾èµ–
pip install -r requirements.txt

# 2. å¯åŠ¨è§†è§‰æ£€æµ‹æœåŠ¡
python Code/GameStateChecker/main_flask_server.py

# 3. å¦ä¸€ç»ˆç«¯ï¼ŒéªŒè¯ API keyï¼ˆå¯é€‰ï¼‰
python Code/bdd/test_api_key.py

# 4. ç”Ÿæˆå¹¶æ‰§è¡Œæµ‹è¯•
python Code/bdd/run_tests.py --mode generated --req "æµ‹è¯•æ¸¸æˆä¸­çš„æ­¦å™¨ç³»ç»Ÿ"
```

è‹¥ä¸€åˆ‡æ­£å¸¸åº”èƒ½çœ‹åˆ° Behave çš„è¾“å‡ºä»¥åŠ â€œæµ‹è¯•å®Œæˆï¼ç»“æœï¼š{â€¦}â€ã€‚

---

### è¿˜æœ‰ä»€ä¹ˆè¦çœ‹çš„ï¼Ÿ

- **å•å…ƒæµ‹è¯•**ï¼š`pytest -q`Â å…ˆè·‘ä¸€ä¸‹ï¼Œå¯ä»¥æå‰æš´éœ² import/path çš„ä½çº§é”™è¯¯ã€‚  
- **æ—¥å¿—**ï¼šé¡¹ç›®é‡Œç”¨ `loguru`ï¼Œåœ¨ `run_tests.py` é¡¶éƒ¨åŠ  `logger.add("debug.log")` ä¼šæ›´å¥½æ’æŸ¥ã€‚  
- **CI/CD**ï¼šå¦‚æœæ‰“ç®—æ”¾åˆ° GitHub Actionsï¼Œè®°å¾—åœ¨ CI é•œåƒé‡Œå®‰è£… tesseract å’Œ OpenCV ä¾èµ–åº“ã€‚

---

å…ˆæŠŠä¸Šé¢å‡ ä¸ªæ˜¾çœ¼çš„å‘å¡«æ‰ï¼ŒåŸºæœ¬å°±èƒ½å®Œæ•´è·‘é€šä¸€æ¡ã€Œç”Ÿæˆâ€¯Gherkin â†’ å†™ .feature â†’ Behave æ‰§è¡Œ â†’ è°ƒ GameStateChecker APIã€çš„æµç¨‹ã€‚åç»­å†æ ¹æ®ä¸šåŠ¡æ•ˆæœå’Œå‡†ç¡®ç‡åšç»†è°ƒã€‚æœ‰ä»€ä¹ˆæ–°çš„æŠ¥é”™è´´å‡ºæ¥å†ä¸€èµ·çœ‹ ã€‚å…³äºä»¥ä¸Šé—®é¢˜ï¼Œä½ æ˜¯å¦å·²ç»è¿›è¡Œäº†ä¿®æ”¹ï¼Ÿå¦å¤–ï¼Œæˆ‘æƒ³ç¡®è®¤ä¸‹APIè°ƒç”¨æ˜¯å¦æœ‰é—®é¢˜ï¼Ÿæ˜¯å¦èƒ½æ’é™¤APIçš„é—®é¢˜
ä»æµ‹è¯•ç»“æœæ¥çœ‹ï¼Œæˆ‘ä»¬ä»ç„¶æœ‰é—®é¢˜éœ€è¦è§£å†³ã€‚å¦ä¸€ä¸ªAIç»™å‡ºçš„åˆ†æç¡®å®å¾ˆæœ‰å¸®åŠ©ï¼Œå®ƒæŒ‡å‡ºäº†å‡ ä¸ªå…³é”®çš„é—®é¢˜ç‚¹ã€‚æ ¹æ®æˆ‘å¯¹é¡¹ç›®çš„äº†è§£å’Œæµ‹è¯•è¾“å‡ºï¼Œè®©æˆ‘ä»¬ç³»ç»Ÿåœ°è§£å†³è¿™äº›é—®é¢˜ï¼š

## 1. é¦–å…ˆè§£å†³åŸºç¡€ä¾èµ–é—®é¢˜

````python
import os
import time
from typing import List, Tuple, Dict
from VisionUtils import VisionUtils
import cv2
import re
from loguru import logger
import numpy as np  # æ·»åŠ numpyå¯¼å…¥
````

## 2. ä¿®å¤æµ‹è¯•æ‰§è¡Œé—®é¢˜

è®©æˆ‘ä»¬ä»`test_ammo_sync.py`å¼€å§‹æ£€æŸ¥ï¼Œçœ‹çœ‹ä¸ºä»€ä¹ˆæ‰€æœ‰æµ‹è¯•éƒ½å¤±è´¥ï¼š

````python
import pytest
import os
from loguru import logger
import asyncio
import cv2
import numpy as np
from src.gherkin.parser import GherkinParser
from src.rivergame.ammo_test_runner import AmmoTestRunner

# ç¡®ä¿æ—¥å¿—ç›®å½•å­˜åœ¨
os.makedirs("logs", exist_ok=True)
logger.add("logs/test_debug.log", level="DEBUG", rotation="1 MB")

@pytest.fixture(scope="module")
def setup_test_environment():
    """è®¾ç½®æµ‹è¯•ç¯å¢ƒ"""
    logger.info("åˆå§‹åŒ–æµ‹è¯•ç¯å¢ƒ")
    
    # æ£€æŸ¥æµ‹è¯•èµ„æº
    resources_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'Code', 'GameStateChecker')
    logger.info(f"æµ‹è¯•èµ„æºè·¯å¾„: {resources_path}")
    
    # åˆ—å‡ºå¯ç”¨çš„æˆªå›¾æ–‡ä»¶
    if os.path.exists(resources_path):
        screenshots = [f for f in os.listdir(resources_path) if f.startswith(('screenShot_', 'aug_screenShot_'))]
        logger.info(f"æ‰¾åˆ° {len(screenshots)} ä¸ªæˆªå›¾æ–‡ä»¶")
        logger.debug(f"å‰5ä¸ªæˆªå›¾: {screenshots[:5]}")
    else:
        logger.error(f"èµ„æºè·¯å¾„ä¸å­˜åœ¨: {resources_path}")
        screenshots = []
    
    # è¿”å›æµ‹è¯•é…ç½®
    return {
        "resources_path": resources_path,
        "screenshots": screenshots,
        "default_bbox": [912, 1015, 79, 49],
        "hsv_range": (129, 130)
    }

@pytest.mark.asyncio
async def test_basic_ammo_sync(setup_test_environment):
    """æµ‹è¯•åŸºæœ¬çš„å¼¹è¯åŒæ­¥åŠŸèƒ½ï¼Œä½¿ç”¨å®é™…å­˜åœ¨çš„æˆªå›¾"""
    logger.info("å¼€å§‹æ‰§è¡ŒåŸºæœ¬å¼¹è¯åŒæ­¥æµ‹è¯•")
    
    # åªæœ‰å½“æœ‰è¶³å¤Ÿçš„æˆªå›¾æ—¶æ‰æ‰§è¡Œæµ‹è¯•
    if len(setup_test_environment["screenshots"]) == 0:
        pytest.skip("æ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„æˆªå›¾æ–‡ä»¶")
    
    # å‡†å¤‡æµ‹è¯•åœºæ™¯ - ä½¿ç”¨å¯ç”¨çš„æˆªå›¾
    gherkin_content = """Feature: Test ammo sync
  Scenario: Check ammo display
    Given the player has 30 bullets
    When the player shoots once
    Then the ammo displayed should be 29"""
    
    logger.info("å¼€å§‹è§£ææµ‹è¯•åœºæ™¯")
    parser = GherkinParser()
    feature = parser.parse_feature(gherkin_content)
    assert feature is not None, "Gherkinè§£æå¤±è´¥"
    
    # æ‰§è¡Œæµ‹è¯•åœºæ™¯
    logger.info("å¼€å§‹æ‰§è¡Œæµ‹è¯•åœºæ™¯")
    runner = AmmoTestRunner()
    # è®¾ç½®è°ƒè¯•æ¨¡å¼
    runner.set_debug_mode(True)
    
    # æ£€æŸ¥å®é™…æˆªå›¾æ–‡ä»¶åæ ¼å¼
    runner.scan_available_screenshots(setup_test_environment["resources_path"])
    
    results = await runner.execute_scenario(feature['scenarios'][0])
    
    # è¯¦ç»†è¾“å‡ºç»“æœ
    print("\næµ‹è¯•æ‰§è¡Œç»“æœ:")
    for step_result in results['steps_results']:
        print(f"{step_result['type']}: {step_result['message']}")
        if not step_result['success']:
            logger.error(f"æ­¥éª¤å¤±è´¥: {step_result.get('error', 'æœªçŸ¥é”™è¯¯')}")
    
    # éªŒè¯ç»“æœ
    assert results['success'], f"æµ‹è¯•æ‰§è¡Œå¤±è´¥: {results.get('error', 'æœªçŸ¥é”™è¯¯')}"

# æš‚æ—¶æ³¨é‡Šæ‰å…¶ä»–æµ‹è¯•ï¼Œå…ˆè®©ä¸€ä¸ªæµ‹è¯•é€šè¿‡
# @pytest.mark.asyncio
# async def test_ammo_sync_with_multiple_shots(setup_test_environment):
#    """æµ‹è¯•å¤šæ¬¡å°„å‡»åœºæ™¯"""
#    ...

# @pytest.mark.asyncio  
# async def test_ammo_sync_with_edge_cases(setup_test_environment):
#    """æµ‹è¯•è¾¹ç•Œæƒ…å†µ"""
#    ...
````

## 3. ä¿®å¤AmmoTestRunnerç±»ä»¥æ”¯æŒæ‰«æå¯ç”¨æˆªå›¾

````python
from typing import Dict, Any, Optional, List
from loguru import logger
import sys
import os
import cv2
import yaml
import re

# æ·»åŠ GameStateCheckerç›®å½•åˆ°Pythonè·¯å¾„
GAME_CHECKER_PATH = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'Code/GameStateChecker')
sys.path.append(GAME_CHECKER_PATH)

try:
    from LogicLayer import LogicLayer
except ImportError as e:
    logger.error(f"æ— æ³•å¯¼å…¥LogicLayer: {e}")
    logger.error(f"æœç´¢è·¯å¾„: {GAME_CHECKER_PATH}")
    logger.error(f"å½“å‰ç›®å½•ä¸­çš„æ–‡ä»¶: {os.listdir(GAME_CHECKER_PATH) if os.path.exists(GAME_CHECKER_PATH) else 'è·¯å¾„ä¸å­˜åœ¨'}")
    raise

class AmmoTestRunner:
    def __init__(self):
        """åˆå§‹åŒ–å¼¹è¯æµ‹è¯•æ‰§è¡Œå™¨"""
        self._current_ammo = 0
        self._logic_layer = LogicLayer()
        self._screenshot_base_path = GAME_CHECKER_PATH
        self._debug_mode = False
        
        # æˆªå›¾æ–‡ä»¶ååŒ¹é…æ¨¡å¼
        self._screenshot_patterns = {}  # å°†å­˜å‚¨ {å¼¹è¯æ•°: æ–‡ä»¶å} çš„æ˜ å°„
        
        # åŠ è½½é…ç½®
        config_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'config.yaml')
        try:
            with open(config_path, 'r') as f:
                self._config = yaml.safe_load(f)
                logger.info("æˆåŠŸåŠ è½½é…ç½®æ–‡ä»¶")
        except Exception as e:
            logger.error(f"åŠ è½½é…ç½®æ–‡ä»¶å¤±è´¥: {e}")
            self._config = {}
            
        logger.info(f"åˆå§‹åŒ–AmmoTestRunner, æˆªå›¾è·¯å¾„: {self._screenshot_base_path}")
        
    def set_debug_mode(self, debug: bool = True):
        """è®¾ç½®è°ƒè¯•æ¨¡å¼"""
        self._debug_mode = debug
        logger.info(f"è®¾ç½®è°ƒè¯•æ¨¡å¼: {debug}")
        
    def scan_available_screenshots(self, path: Optional[str] = None):
        """æ‰«æå¯ç”¨çš„æˆªå›¾æ–‡ä»¶å¹¶åˆ†æå‘½åæ¨¡å¼"""
        if path:
            self._screenshot_base_path = path
            
        logger.info(f"æ‰«ææˆªå›¾ç›®å½•: {self._screenshot_base_path}")
        
        if not os.path.exists(self._screenshot_base_path):
            logger.error(f"æˆªå›¾ç›®å½•ä¸å­˜åœ¨: {self._screenshot_base_path}")
            return
            
        # è·å–æ‰€æœ‰å¯èƒ½çš„æˆªå›¾æ–‡ä»¶
        files = [f for f in os.listdir(self._screenshot_base_path) 
                if f.startswith(('screenShot_', 'aug_screenShot_'))]
        
        logger.info(f"æ‰¾åˆ° {len(files)} ä¸ªå¯èƒ½çš„æˆªå›¾æ–‡ä»¶")
        
        # åˆ†ææ–‡ä»¶åæ¨¡å¼å’Œæå–å¼¹è¯æ•°
        pattern = re.compile(r'(?:aug_)?screenShot_(\d+)\.png')
        
        for filename in files:
            match = pattern.match(filename)
            if match:
                num_str = match.group(1)
                try:
                    # å°è¯•ä¸åŒçš„è§£ææ–¹å¼
                    if len(num_str) >= 3 and num_str.endswith('00'):
                        # å¯èƒ½æ˜¯å¼¹è¯æ•°Ã—100çš„æ ¼å¼
                        ammo = int(num_str) // 100
                    else:
                        # å¯èƒ½ç›´æ¥æ˜¯å¼¹è¯æ•°
                        ammo = int(num_str)
                        
                    self._screenshot_patterns[ammo] = filename
                    logger.debug(f"å¼¹è¯æ•° {ammo} å¯¹åº”æˆªå›¾: {filename}")
                except ValueError:
                    logger.warning(f"æ— æ³•ä»æ–‡ä»¶åè§£æå¼¹è¯æ•°: {filename}")
        
        logger.info(f"æˆåŠŸè¯†åˆ« {len(self._screenshot_patterns)} ä¸ªå¼¹è¯æ•°å¯¹åº”çš„æˆªå›¾")
        
        # æ‰“å°å‡ ä¸ªç¤ºä¾‹ä»¥ä¾›å‚è€ƒ
        examples = list(self._screenshot_patterns.items())[:5]
        if examples:
            logger.info(f"ç¤ºä¾‹æ˜ å°„: {examples}")
        else:
            logger.warning("æœªèƒ½è¯†åˆ«ä»»ä½•å¼¹è¯æ•°ä¸æˆªå›¾çš„å¯¹åº”å…³ç³»")
            
    async def execute_scenario(self, scenario: Dict[str, Any]) -> Dict[str, Any]:
        """æ‰§è¡Œå¼¹è¯æµ‹è¯•åœºæ™¯"""
        try:
            logger.info(f"å¼€å§‹æ‰§è¡Œæµ‹è¯•åœºæ™¯: {scenario['name']}")
            
            # å¦‚æœè¿˜æ²¡æœ‰æ‰«ææˆªå›¾ï¼Œå…ˆæ‰«æä¸€é
            if not self._screenshot_patterns:
                self.scan_available_screenshots()
                
            results = {
                'scenario_name': scenario['name'],
                'steps_results': [],
                'success': True
            }
            
            for step in scenario['steps']:
                logger.debug(f"æ‰§è¡Œæ­¥éª¤: {step['type']} - {step.get('content', '')}")
                step_result = await self._execute_step(step)
                results['steps_results'].append(step_result)
                
                if not step_result['success']:
                    logger.error(f"æ­¥éª¤æ‰§è¡Œå¤±è´¥: {step_result.get('error', 'æœªçŸ¥é”™è¯¯')}")
                    results['success'] = False
                    break
                else:
                    logger.info(f"æ­¥éª¤æ‰§è¡ŒæˆåŠŸ: {step_result['message']}")
            
            return results
            
        except Exception as e:
            error_msg = f"æ‰§è¡Œæµ‹è¯•åœºæ™¯å¤±è´¥: {str(e)}"
            logger.exception(error_msg)
            return {
                'scenario_name': scenario.get('name', 'Unknown'),
                'error': error_msg,
                'success': False,
                'steps_results': []
            }
    
    async def _execute_step(self, step: Dict[str, Any]) -> Dict[str, Any]:
        """æ‰§è¡Œå•ä¸ªæµ‹è¯•æ­¥éª¤"""
        try:
            step_type = step['type']
            params = step.get('params', {})
            logger.debug(f"æ‰§è¡Œæ­¥éª¤ç±»å‹: {step_type}, å‚æ•°: {params}")
            
            if step_type == 'given':
                if 'initial_ammo' in params:
                    self._current_ammo = params['initial_ammo']
                    logger.debug(f"è®¾ç½®åˆå§‹å¼¹è¯æ•°ä¸º: {self._current_ammo}")
                    
                    # ç‰¹åˆ«å¤„ç†å¼¹è¯ä¸º0çš„æƒ…å†µ
                    if self._current_ammo == 0:
                        logger.info("è®¾ç½®åˆå§‹å¼¹è¯ä¸º0ï¼Œå°†ä½¿ç”¨ç‰¹æ®Šå¤„ç†é€»è¾‘")
                    
                    screenshot = self._load_screenshot(self._current_ammo)
                    
                    if screenshot is None:
                        error_msg = f"æ— æ³•åŠ è½½åˆå§‹å¼¹è¯æ•°ä¸º {self._current_ammo} çš„æˆªå›¾"
                        logger.error(error_msg)
                        return {
                            'type': step_type,
                            'message': error_msg,
                            'success': False,
                            'error': error_msg
                        }
                        
                    return {
                        'type': step_type,
                        'message': f"è®¾ç½®åˆå§‹å¼¹è¯æ•°ä¸º: {self._current_ammo}",
                        'success': True
                    }
                    
            elif step_type == 'when':
                if 'shots' in params:
                    shots = params['shots']
                    old_ammo = self._current_ammo
                    self._current_ammo = max(0, self._current_ammo - shots)
                    logger.debug(f"å‘å°„å­å¼¹: {shots} å‘ï¼Œå¼¹è¯æ•°ä» {old_ammo} å˜ä¸º {self._current_ammo}")
                    
                    # ç‰¹åˆ«å¤„ç†å¼¹è¯ä¸º0çš„æƒ…å†µ
                    if self._current_ammo == 0:
                        logger.info("å°„å‡»åå¼¹è¯ä¸º0ï¼Œå°†ä½¿ç”¨ç‰¹æ®Šå¤„ç†é€»è¾‘")
                    
                    screenshot = self._load_screenshot(self._current_ammo)
                    if screenshot is None:
                        error_msg = f"æ— æ³•åŠ è½½å°„å‡»åå¼¹è¯æ•°ä¸º {self._current_ammo} çš„æˆªå›¾"
                        logger.error(error_msg)
                        return {
                            'type': step_type,
                            'message': error_msg,
                            'success': False,
                            'error': error_msg
                        }
                        
                    return {
                        'type': step_type,
                        'message': f"å‘å°„äº† {shots} å‘å­å¼¹ï¼Œå‰©ä½™ {self._current_ammo}",
                        'success': True
                    }
                    
            elif step_type == 'then':
                screenshot = self._load_screenshot(self._current_ammo)
                if screenshot is None:
                    error_msg = f"æ— æ³•åŠ è½½éªŒè¯é˜¶æ®µçš„æ¸¸æˆæˆªå›¾ (å¼¹è¯æ•°: {self._current_ammo})"
                    logger.error(error_msg)
                    return {
                        'type': step_type,
                        'message': error_msg,
                        'success': False,
                        'error': error_msg
                    }
                
                if 'check_sync' in params and params['check_sync']:
                    is_sync = self._verify_ammo_sync(screenshot, self._current_ammo)
                    result_msg = f"éªŒè¯å¼¹è¯æ˜¾ç¤ºåŒæ­¥çŠ¶æ€: {'æˆåŠŸ' if is_sync else 'å¤±è´¥'}"
                    logger.info(result_msg)
                    return {
                        'type': step_type,
                        'message': result_msg,
                        'success': is_sync
                    }
                elif 'expected_ammo' in params:
                    expected = params['expected_ammo']
                    is_sync = self._verify_ammo_sync(screenshot, expected)
                    result_msg = f"éªŒè¯å¼¹è¯æ•°é‡: æœŸæœ›={expected}, å®é™…={self._current_ammo}"
                    logger.info(f"{result_msg}, åŒæ­¥çŠ¶æ€: {'æˆåŠŸ' if is_sync else 'å¤±è´¥'}")
                    return {
                        'type': step_type,
                        'message': result_msg,
                        'success': is_sync and self._current_ammo == expected
                    }
            
            error_msg = f"æœªçŸ¥çš„æµ‹è¯•æ­¥éª¤ç±»å‹: {step_type}"
            logger.warning(error_msg)
            return {
                'type': step_type,
                'message': error_msg,
                'success': False,
                'error': error_msg
            }
            
        except Exception as e:
            error_msg = f"æ‰§è¡Œæµ‹è¯•æ­¥éª¤å¤±è´¥: {e}"
            logger.exception(error_msg)
            return {
                'type': step_type if 'step_type' in locals() else 'unknown',
                'error': error_msg,
                'success': False,
                'message': error_msg
            }
            
    def _load_screenshot(self, ammo_count: int) -> Optional[Any]:
        """åŠ è½½å¯¹åº”å¼¹è¯æ•°é‡çš„æ¸¸æˆæˆªå›¾"""
        try:
            # ä»é¢„æ‰«æçš„æ˜ å°„ä¸­è·å–æ–‡ä»¶å
            if ammo_count in self._screenshot_patterns:
                screenshot_path = os.path.join(self._screenshot_base_path, self._screenshot_patterns[ammo_count])
                logger.debug(f"ä½¿ç”¨é¢„æ‰«ææ˜ å°„åŠ è½½æˆªå›¾: {screenshot_path}")
                
                image = cv2.imread(screenshot_path)
                if image is not None:
                    logger.info(f"æˆåŠŸåŠ è½½æˆªå›¾: {screenshot_path}")
                    # ä¿å­˜è°ƒè¯•å›¾åƒ
                    if self._debug_mode:
                        debug_dir = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), 'debug')
                        os.makedirs(debug_dir, exist_ok=True)
                        debug_path = os.path.join(debug_dir, f"loaded_screenshot_{ammo_count}.png")
                        cv2.imwrite(debug_path, image)
                        logger.debug(f"ä¿å­˜è°ƒè¯•å›¾åƒ: {debug_path}")
                    return image
                else:
                    logger.warning(f"æ— æ³•è¯»å–æˆªå›¾å†…å®¹: {screenshot_path}")
                    return None
            
            # å¦‚æœé¢„æ‰«ææ˜ å°„ä¸­æ²¡æœ‰ï¼Œå°è¯•å¸¸è§çš„æ–‡ä»¶åæ¨¡å¼
            screenshot_patterns = [
                f"screenShot_{ammo_count*100}.png",
                f"aug_screenShot_{ammo_count*100}.png",
                f"screenShot_{ammo_count}.png",
                f"aug_screenShot_{ammo_count}.png"
            ]
            
            for pattern in screenshot_patterns:
                screenshot_path = os.path.join(self._screenshot_base_path, pattern)
                logger.debug(f"å°è¯•åŠ è½½æˆªå›¾: {screenshot_path}")
                
                if os.path.exists(screenshot_path):
                    image = cv2.imread(screenshot_path)
                    if image is not None:
                        logger.info(f"æˆåŠŸåŠ è½½æˆªå›¾: {screenshot_path}")
                        # è®°å½•åˆ°æ˜ å°„ä¸­ä»¥ä¾¿ä¸‹æ¬¡ä½¿ç”¨
                        self._screenshot_patterns[ammo_count] = pattern
                        return image
            
            logger.error(f"æ‰¾ä¸åˆ°å¯¹åº”å¼¹è¯æ•°{ammo_count}çš„æˆªå›¾ï¼Œå°è¯•è¿‡çš„æ¨¡å¼: {screenshot_patterns}")
            return None
            
        except Exception as e:
            logger.exception(f"åŠ è½½æˆªå›¾å¤±è´¥: {e}")
            return None
            
    def _verify_ammo_sync(self, screenshot: Any, expected_ammo: int) -> bool:
        """éªŒè¯å¼¹è¯åŒæ­¥çŠ¶æ€"""
        try:
            logger.debug(f"å¼€å§‹éªŒè¯å¼¹è¯åŒæ­¥ï¼ŒæœŸæœ›å€¼: {expected_ammo}")
            
            # ä»é…ç½®æ–‡ä»¶æˆ–é»˜è®¤å€¼è·å–éªŒè¯å‚æ•°
            vision_config = self._config.get('vision', {}).get('ammo', {})
            context = {
                "bbox": vision_config.get('bbox', [912, 1015, 79, 49]),
                "textColorValueInHSV_min": vision_config.get('color_hsv_min', 129),
                "textColorValueInHSV_max": vision_config.get('color_hsv_max', 130)
            }
            
            # è°ƒç”¨LogicLayeréªŒè¯
            result = self._logic_layer.testAmmoTextInSync(
                screenshots=[screenshot],
                context=context,
                expectedAnswer={"intResult": expected_ammo},
                debugEnabled=self._debug_mode
            )
            
            logger.info(f"å¼¹è¯åŒæ­¥éªŒè¯ç»“æœ: {result}")
            return result
            
        except Exception as e:
            logger.exception(f"éªŒè¯å¼¹è¯åŒæ­¥å¤±è´¥: {e}")
            return False
````

## 4. ä¿®å¤GherkinParserä»¥ç¡®ä¿æ­£ç¡®è§£æå‚æ•°

````python
from typing import Dict, Any, Optional
from loguru import logger
import re

class GherkinParser:
    def __init__(self):
        """åˆå§‹åŒ–Gherkinè§£æå™¨"""
        self.step_patterns = {
            'given_ammo': r'the player has (\d+) bullets?',
            'when_shoot': r'the player shoots? (?:once|(\d+) times?)',
            'then_ammo': r'the ammo displayed should be (\d+)',
            'then_sync': r'the ammo displayed should match the internal ammo'
        }
    
    def parse_feature(self, content: str) -> Optional[Dict[str, Any]]:
        """è§£æGherkinç‰¹æ€§æ–‡ä»¶å†…å®¹"""
        if not content or not isinstance(content, str):
            logger.error("æ— æ•ˆçš„Gherkinå†…å®¹")
            return None
            
        try:
            lines = [line.strip() for line in content.split('\n') if line.strip()]
            feature = {
                'name': '',
                'scenarios': []
            }
            
            current_scenario = None
            
            for line in lines:
                if line.startswith('Feature:'):
                    feature['name'] = line[8:].strip()
                    logger.debug(f"è§£æåˆ°ç‰¹æ€§åç§°: {feature['name']}")
                    
                elif line.startswith('Scenario:'):
                    if current_scenario:
                        feature['scenarios'].append(current_scenario)
                        
                    current_scenario = {
                        'name': line[9:].strip(),
                        'steps': []
                    }
                    logger.debug(f"è§£æåˆ°åœºæ™¯åç§°: {current_scenario['name']}")
                    
                else:
                    # è§£ææ­¥éª¤
                    step = self._parse_step(line)
                    if step and current_scenario:
                        logger.debug(f"è§£æåˆ°æ­¥éª¤: {step}")
                        current_scenario['steps'].append(step)
            
            if current_scenario:
                feature['scenarios'].append(current_scenario)
            
            logger.info(f"è§£æå®Œæˆ: æ‰¾åˆ° {len(feature['scenarios'])} ä¸ªåœºæ™¯")
            return feature
            
        except Exception as e:
            logger.exception(f"è§£æGherkinå†…å®¹å¤±è´¥: {e}")
            return None
    
    def _parse_step(self, line: str) -> Optional[Dict[str, Any]]:
        """è§£æå•ä¸ªæ­¥éª¤"""
        try:
            for keyword in ['Given', 'When', 'Then']:
                if line.startswith(keyword):
                    content = line[len(keyword):].strip()
                    step_type = keyword.lower()
                    
                    logger.debug(f"æ£€æµ‹åˆ°æ­¥éª¤ç±»å‹: {step_type}, å†…å®¹: {content}")
                    params = self._extract_params(step_type, content)
                    
                    if params is not None:
                        return {
                            'type': step_type,
                            'content': content,
                            'params': params
                        }
                    else:
                        logger.warning(f"æ— æ³•æå–å‚æ•°: {step_type} - {content}")
            return None
            
        except Exception as e:
            logger.exception(f"è§£ææ­¥éª¤å¤±è´¥: {e}")
            return None
    
    def _extract_params(self, step_type: str, content: str) -> Optional[Dict[str, Any]]:
        """æå–æ­¥éª¤å‚æ•°"""
        try:
            if step_type == 'given':
                match = re.search(self.step_patterns['given_ammo'], content)
                if match:
                    return {'initial_ammo': int(match.group(1))}
                    
            elif step_type == 'when':
                match = re.search(self.step_patterns['when_shoot'], content)
                if match:
                    shots = match.group(1)
                    return {'shots': 1 if not shots else int(shots)}
                    
            elif step_type == 'then':
                match = re.search(self.step_patterns['then_ammo'], content)
                if match:
                    return {'expected_ammo': int(match.group(1))}
                    
                match = re.search(self.step_patterns['then_sync'], content)
                if match:
                    return {'check_sync': True}
            
            logger.warning(f"æ— æ³•æå–å‚æ•°ï¼Œæ­¥éª¤ç±»å‹: {step_type}, å†…å®¹: {content}")
            return {}  # è¿”å›ç©ºå­—å…¸è€Œä¸æ˜¯Noneï¼Œé¿å…åç»­å‡ºé”™
            
        except Exception as e:
            logger.exception(f"æå–å‚æ•°å¤±è´¥: {e}")
            return {}  # è¿”å›ç©ºå­—å…¸è€Œä¸æ˜¯None
    
    def validate_gherkin(self, content: str) -> bool:
        """éªŒè¯Gherkinè¯­æ³•æ˜¯å¦æ­£ç¡®"""
        if not content or not isinstance(content, str):
            return False
            
        try:
            feature = self.parse_feature(content)
            if not feature:
                return False
                
            if not feature['name'] or not feature['scenarios']:
                return False
                
            for scenario in feature['scenarios']:
                if not scenario['name'] or not scenario['steps']:
                    return False
                    
                # æ£€æŸ¥æ­¥éª¤åºåˆ—
                if not self._validate_scenario_steps(scenario['steps']):
                    return False
            
            return True
            
        except Exception as e:
            logger.exception(f"éªŒè¯Gherkinè¯­æ³•å¤±è´¥: {e}")
            return False
    
    def _validate_scenario_steps(self, steps: list) -> bool:
        """éªŒè¯åœºæ™¯æ­¥éª¤çš„æœ‰æ•ˆæ€§"""
        try:
            if not steps:
                return False
                
            # éªŒè¯æ˜¯å¦åŒ…å«å¿…è¦çš„æ­¥éª¤ç±»å‹
            step_types = [step['type'] for step in steps]
            
            # æ£€æŸ¥æ˜¯å¦è‡³å°‘æœ‰given
            if 'given' not in step_types:
                logger.warning("åœºæ™¯ä¸­ç¼ºå°‘Givenæ­¥éª¤")
                return False
                
            # æ£€æŸ¥æ˜¯å¦è‡³å°‘æœ‰then
            if 'then' not in step_types:
                logger.warning("åœºæ™¯ä¸­ç¼ºå°‘Thenæ­¥éª¤")
                return False
            
            # éªŒè¯é¡ºåº
            for i, step_type in enumerate(step_types):
                if step_type == 'given' and i > 0 and step_types[i-1] != 'given':
                    logger.warning("Givenæ­¥éª¤å¿…é¡»åœ¨åœºæ™¯å¼€å§‹")
                    return False
                    
                if step_type == 'then' and i > 0 and step_types[i-1] not in ['given', 'when', 'then']:
                    logger.warning("Thenæ­¥éª¤å¿…é¡»åœ¨Given/Whenä¹‹å")
                    return False
            
            return True
            
        except Exception as e:
            logger.exception(f"éªŒè¯åœºæ™¯æ­¥éª¤å¤±è´¥: {e}")
            return False
````

## 5. ä¿®å¤APIè°ƒç”¨çš„é—®é¢˜

è®©æˆ‘ä»¬æ£€æŸ¥ä¸€ä¸‹OpenAI APIçš„è°ƒç”¨é—®é¢˜ï¼š

````python
import os
import yaml
import openai
from typing import Dict, Any
from loguru import logger

class GPTClient:
    def __init__(self, config_path: str = "config.yaml"):
        # åŠ è½½é…ç½®
        try:
            with open(config_path, "r") as f:
                config = yaml.safe_load(f)
                
            # è®¾ç½®APIå¯†é’¥
            openai.api_key = config["api"]["openai"]["api_key"]
            self.model = config["api"]["openai"]["model"]
            self.temperature = config["api"]["openai"]["temperature"]
            self.max_tokens = config["api"]["openai"]["max_tokens"]
            logger.info(f"GPTå®¢æˆ·ç«¯åˆå§‹åŒ–æˆåŠŸï¼Œä½¿ç”¨æ¨¡å‹: {self.model}")
        except Exception as e:
            logger.error(f"åˆå§‹åŒ–GPTå®¢æˆ·ç«¯å¤±è´¥: {e}")
            # å°è¯•ä»ç¯å¢ƒå˜é‡è·å–APIå¯†é’¥
            openai.api_key = os.getenv("OPENAI_API_KEY")
            self.model = os.getenv("OPENAI_MODEL", "gpt-3.5-turbo")  # é»˜è®¤ä½¿ç”¨è¾ƒå¹¿æ³›æ”¯æŒçš„æ¨¡å‹
            self.temperature = float(os.getenv("OPENAI_TEMPERATURE", "0.7"))
            self.max_tokens = int(os.getenv("OPENAI_MAX_TOKENS", "1000"))
            logger.warning(f"ä½¿ç”¨ç¯å¢ƒå˜é‡ä¸­çš„è®¾ç½®ï¼Œæ¨¡å‹: {self.model}")
    
    async def generate_test_scenario(self, prompt: str) -> str:
        """è°ƒç”¨GPTç”Ÿæˆæµ‹è¯•åœºæ™¯"""
        try:
            logger.info("å¼€å§‹è°ƒç”¨GPTç”Ÿæˆæµ‹è¯•åœºæ™¯")
            
            # é¿å…ä½¿ç”¨å·²å¼ƒç”¨çš„API
            client = openai.OpenAI(api_key=openai.api_key)
            response = await client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": "ä½ æ˜¯ä¸€ä¸ªæ¸¸æˆæµ‹è¯•ä¸“å®¶ï¼Œä¸“æ³¨äºç”Ÿæˆç¬¦åˆGherkinè¯­æ³•çš„æµ‹è¯•åœºæ™¯ã€‚"},
                    {"role": "user", "content": prompt}
                ],
                temperature=self.temperature,
                max_tokens=self.max_tokens
            )
            
            logger.info("GPTå“åº”æˆåŠŸ")
            return response.choices[0].message.content
        except Exception as e:
            logger.exception(f"GPT APIè°ƒç”¨å¤±è´¥: {e}")
            return None
````

## 6. æ·»åŠ åº”ç”¨äºå…¨å±€çš„å¼‚å¸¸å¤„ç†å’Œæ—¥å¿—

åˆ›å»ºä¸€ä¸ªæ–°çš„conftest.pyæ–‡ä»¶æ¥å¤„ç†pytestçš„å¸¸è§é—®é¢˜ï¼š

````python
import pytest
import os
from loguru import logger
import asyncio

# ç¡®ä¿æ—¥å¿—å’Œè°ƒè¯•ç›®å½•å­˜åœ¨
os.makedirs("logs", exist_ok=True)
os.makedirs("debug", exist_ok=True)

# é…ç½®æ—¥å¿—
logger.remove()  # ç§»é™¤é»˜è®¤å¤„ç†å™¨
logger.add("logs/test_run.log", level="DEBUG", rotation="1 MB")
logger.add(lambda msg: print(msg), level="INFO")

@pytest.fixture(scope="session")
def setup_logging():
    """è®¾ç½®æ—¥å¿—è®°å½•"""
    return logger

# é‡æ–°å®šä¹‰event_loopä»¥é¿å…è­¦å‘Š
@pytest.fixture(scope="session")
def event_loop():
    """åˆ›å»ºä¸€ä¸ªä¼šè¯çº§åˆ«çš„äº‹ä»¶å¾ªç¯"""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()
````

## è¿è¡Œå•ä¸ªæµ‹è¯•æ¥ç¡®å®šé—®é¢˜

ç°åœ¨æˆ‘ä»¬å·²ç»ç³»ç»Ÿåœ°ä¿®æ”¹äº†ä»£ç ï¼Œè§£å†³äº†ä¾èµ–é—®é¢˜ã€è·¯å¾„é—®é¢˜ã€å¼‚æ­¥é—®é¢˜ç­‰ã€‚è®©æˆ‘ä»¬å…ˆè¿è¡Œä¸€ä¸ªå•ä¸€çš„æµ‹è¯•æ¥è¯Šæ–­ä»»ä½•å‰©ä½™çš„é—®é¢˜ï¼š

```
python -m pytest tests/test_ammo_sync.py::test_basic_ammo_sync -v
```

é€šè¿‡è¿™å¥—ä¿®æ”¹ï¼Œæˆ‘ä»¬åº”è¯¥èƒ½å¤Ÿè§£å†³ä¹‹å‰é‡åˆ°çš„å‡ ä¸ªä¸»è¦é—®é¢˜ï¼š
1. ä¾èµ–é—®é¢˜ - æ·»åŠ äº†ç¼ºå°‘çš„numpyå¯¼å…¥
2. è·¯å¾„é—®é¢˜ - æ”¹è¿›äº†æˆªå›¾æŸ¥æ‰¾é€»è¾‘
3. å‚æ•°è§£æé—®é¢˜ - å¢å¼ºäº†GherkinParserçš„å‚æ•°æå–
4. APIè°ƒç”¨é—®é¢˜ - æ›´æ–°äº†OpenAI APIçš„è°ƒç”¨æ–¹å¼
5. è°ƒè¯•ä¿¡æ¯ - æ·»åŠ äº†æ›´å¤šçš„æ—¥å¿—è®°å½•

è¿™äº›æ”¹åŠ¨åº”è¯¥å¯ä»¥è®©æµ‹è¯•æ¡†æ¶æ­£ç¡®è¿è¡Œï¼Œå¦‚æœè¿˜æœ‰ä»»ä½•ç‰¹å®šé—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®æ–°çš„é”™è¯¯æ¶ˆæ¯ç»§ç»­è°ƒæ•´ã€‚
### 1â€¯ä»£ç é‡Œåˆ°åº•åœ¨è°ƒç”¨å“ªä¸ªâ€¯GPTâ€¯æ¨¡å‹ï¼Ÿ

| ä½ç½® | è°ƒç”¨æ–¹å¼ | å½“å‰ç¡¬ç¼–ç æ¨¡å‹ |
| --- | --- | --- |
| `Code/bdd/test_api_key.py`â€¯&â€¯`update_api_key.py` | `openai.ChatCompletion.create(...)` | `"gpt-4"` îˆ€citeîˆ‚turn2file0îˆ |
| `Code/bdd/test_generator/llm_generator.py` | åŒä¸Š | `self.model = "gpt-4"` îˆ€citeîˆ‚turn2file6îˆ |
| `src/llm/gpt_client.py` | `AsyncOpenAI`Â å®¢æˆ·ç«¯ï¼›æ¨¡å‹åä»â€¯`config.yaml`Â è¯»å– | å–å†³äºé…ç½®æ–‡ä»¶ îˆ€citeîˆ‚turn2file3îˆ |

> **ç»“è®º**  
> *é™¤ `src/llm/gpt_client.py` èµ°é…ç½®æ–‡ä»¶å¤–ï¼Œæ‰€æœ‰è„šæœ¬éƒ½å†™æ­»äº†Â `"gpt-4"`ã€‚*

---

### 2â€¯APIÂ è°ƒç”¨æœ‰æ²¡æœ‰é—®é¢˜ï¼Ÿ

| å¸¸è§å‘ | ä»£ç ç°çŠ¶ | å»ºè®®ä¿®å¤ |
| --- | --- | --- |
| **æ¨¡å‹åç¡¬ç¼–ç ** â†’ åˆ‡æ¢åˆ°â€¯`gptâ€‘4o`â€¯æˆ–â€¯`gptâ€‘3.5â€‘turbo` éœ€è¦æ”¹æºç  | å¤šå¤„ç›´æ¥å†™ `"gpt-4"` | æŠŠæ¨¡å‹åæåˆ°ç¯å¢ƒå˜é‡æˆ– CLI å‚æ•°ï¼Œä¾‹å¦‚ `os.getenv("OPENAI_MODEL", "gpt-4o")` |
| **åŒæ­¥ vs. å¼‚æ­¥ SDK** | test_* è„šæœ¬ç”¨ `openai.ChatCompletion.create`ï¼ˆåŒæ­¥ï¼‰ï¼›`gpt_client.py` ç”¨ `AsyncOpenAI`ï¼ˆå¼‚æ­¥ï¼‰ | äºŒé€‰ä¸€å³å¯ï¼›å¦‚æœæƒ³ç»Ÿä¸€ç”¨å¼‚æ­¥ï¼Œæ”¹ test_* è„šæœ¬ä¸º `await client.chat.completions.create(...)` |
| **å¯†é’¥åŠ è½½ä½ç½®ä¸ç»Ÿä¸€** | test_* è„šæœ¬é  `.env`ï¼›`gpt_client.py` èµ° `config.yaml` | ç»Ÿä¸€æ–¹æ¡ˆï¼šåªåœ¨ `.env` å­˜ `OPENAI_API_KEY`ï¼Œä»£ç é‡Œç”¨ `os.getenv`ï¼›config æ–‡ä»¶é‡Œä¸è¦å†å­˜å¯†é’¥ |
| **å¼‚å¸¸å¤„ç†** | ç›®å‰åª `print(e)` | æŠŠå¼‚å¸¸å¾€ä¸ŠæŠ›æˆ–è€…ç”¨Â `logger.exception`ï¼Œå¹¶åœ¨è°ƒç”¨å¤„é‡è¯•æˆ–ç»™å‡ºå‹å¥½æç¤º |

---

### 3â€¯å…³äº OPENAI_API_KEY â€¯Â â€œæœ‰å‡ ç§ï¼Ÿâ€

- **åªæœ‰ä¸€ç§**ã€‚ä¸åˆ† â€œGPTâ€‘4â€¯keyâ€ å’Œ â€œGPTâ€‘4oâ€¯keyâ€ã€‚  
  åªè¦ä½ çš„è´¦å·å¼€é€šäº†å¯¹åº”æ¨¡å‹çš„æƒé™ï¼Œ**åŒä¸€æ¡** `OPENAI_API_KEY` å°±èƒ½è°ƒ `gptâ€‘3.5â€‘turbo`ã€`gptâ€‘4`, `gptâ€‘4o` ç­‰ã€‚

---

### 4â€¯ä¸åŒæ¨¡å‹çš„è°ƒç”¨æ ¼å¼ä¸€æ ·å—ï¼Ÿ

| æ¨¡å‹ | Endpoint | å¿…è¦å‚æ•° | ç»†èŠ‚å·®å¼‚ |
| --- | --- | --- | --- |
| `gptâ€‘3.5â€‘turbo`<br>`gptâ€‘4`<br>`gptâ€‘4o` | `POST /v1/chat/completions` | `model`, `messages` | **å®Œå…¨ä¸€è‡´**ï¼›å¯ä»¥åœ¨åŒä¸€ä¸ªå­—æ®µé‡Œåˆ‡æ¢æ¨¡å‹å |
| `gptâ€‘4oâ€‘mini`Â (å¦‚æœæ—¥åæ¨å‡º) | é¢„è®¡ç›¸åŒ | åŒä¸Š | å¯èƒ½é»˜è®¤â€¯`json_mode`â€¯/â€¯`vision`â€¯ç­‰å‚æ•°ï¼Œä½†å‘åå…¼å®¹ |
| Vision æˆ–å¤šæ¨¡æ€ç‰ˆæœ¬ | ä»æ˜¯ `chat/completions` | å¤šä¸€ä¸ª `image_url` | ä»…åœ¨ message content ä¸­åµŒå…¥å›¾ç‰‡ URLï¼Œæ ¼å¼ç¨æœ‰ä¸åŒ |

å› æ­¤ **ä½ æ— éœ€ä¸ºâ€¯`gptâ€‘4o`â€¯ä¿®æ”¹è°ƒç”¨ä»£ç **ï¼›åªè¦æŠŠ `model="gpt-4"` æ¢æˆ `model="gpt-4o"` å³å¯ã€‚

---

### 5â€¯ç»™ä½ çš„ä¸€ä»½â€œæœ€å°æ”¹åŠ¨â€æ¸…å•

1. **æŠ½ç¦»æ¨¡å‹å**  
   ```python
   MODEL_NAME = os.getenv("OPENAI_MODEL", "gpt-4o")
   response = openai.ChatCompletion.create(
       model=MODEL_NAME,
       messages=[...],
   )
   ```
2. **ç»Ÿä¸€å¯†é’¥åŠ è½½**  
   ```python
   from dotenv import load_dotenv; load_dotenv()
   openai.api_key = os.getenv("OPENAI_API_KEY")
   ```
3. **requirements**  
   ```
   openai>=1.14.0   # ç¡®ä¿æ”¯æŒ gptâ€‘4o
   ```
4. **config.yamlï¼ˆå¯é€‰ï¼‰**  
   ```yaml
   api:
     openai:
       model: gpt-4o
       temperature: 0.7
       max_tokens: 1024
   ```

---

### 6â€¯å¿«é€Ÿè‡ªæ£€è„šæœ¬

```bash
export OPENAI_API_KEY=sk-...
export OPENAI_MODEL=gpt-4o     # æˆ– gpt-3.5-turbo

python Code/bdd/test_api_key.py        # éªŒè¯è¿é€šæ€§
python Code/bdd/run_tests.py --mode generated
```

è‹¥èƒ½æ­£å¸¸è¿”å› ChatCompletionï¼Œå°±è¯´æ˜ **å¯†é’¥ + æ¨¡å‹ + SDK ç‰ˆæœ¬** éƒ½åŒ¹é…ã€‚

---

å¦‚æœ‰æ›´å¤šé”™è¯¯æ—¥å¿—æˆ–éœ€è¦æ”¯æŒ Azureï¼ä»£ç†ç«¯ç‚¹ï¼Œå†è´´å‡ºæ¥ä¸€èµ·æ’æŸ¥ã€‚å…³äºAPIçš„è°ƒç”¨ï¼Œæ˜¯å¦æœ‰é—®é¢˜ï¼Ÿèƒ½å¦å¼„ä¸€ä¸ªtestæ–‡ä»¶æ£€æŸ¥ä¸‹ï¼Œå¦å¤–ç°åœ¨å¥½åƒåªæœ‰4oäº†ï¼Œèƒ½å¦è°ƒç”¨æ¨¡å‹æ”¹ä¸º4oè€Œä¸æ˜¯4ã€‚å¦å¤–è¿™æ˜¯è¿è¡Œå•ä¸€æµ‹è¯•åçš„æŠ¥é”™ä¿¡æ¯ï¼š2025-04-14 11:21:37.573 | INFO     | test_ammo_sync:setup_test_environment:13 - åˆå§‹åŒ–æµ‹è¯•ç¯å¢ƒ
---------------------------------------------------------------------------------------------------------------- Captured log setup ---------------------------------------------------------------------------------------------------------------- 
DEBUG    asyncio:proactor_events.py:630 Using proactor: IocpProactor
DEBUG    asyncio:proactor_events.py:630 Using proactor: IocpProactor
--------------------------------------------------------------------------------------------------------------- Captured stderr call --------------------------------------------------------------------------------------------------------------- 
2025-04-14 11:21:37.577 | INFO     | test_ammo_sync:test_basic_ammo_sync:29 - å¼€å§‹æ‰§è¡ŒåŸºæœ¬å¼¹è¯åŒæ­¥æµ‹è¯•
2025-04-14 11:21:37.578 | INFO     | LogicLayer:__init__:13 - åˆå§‹åŒ–LogicLayerï¼ŒåŸºç¡€è·¯å¾„: C:\Users\96116\game-testing-main\Code\GameStateChecker
2025-04-14 11:21:37.578 | DEBUG    | LogicLayer:preloadData:32 - åŠ è½½æ¨¡æ¿å›¾åƒ: C:\Users\96116\game-testing-main\Code\GameStateChecker\unitTestResources\Cross_p.png
2025-04-14 11:21:37.578 | ERROR    | src.rivergame.ammo_test_runner:__init__:27 - åŠ è½½é…ç½®æ–‡ä»¶å¤±è´¥: 'gbk' codec can't decode byte 0xa1 in position 434: illegal multibyte sequence
2025-04-14 11:21:37.587 | INFO     | src.rivergame.ammo_test_runner:__init__:30 - åˆå§‹åŒ–AmmoTestRunner, æˆªå›¾è·¯å¾„: C:\Users\96116\game-testing-main\src\rivergame\../../Code/GameStateChecker
2025-04-14 11:21:37.587 | INFO     | src.rivergame.ammo_test_runner:setup_vision_params:47 - æ›´æ–°è§†è§‰æ£€æµ‹å‚æ•°: {'bbox': [912, 1015, 79, 49], 'hsv_min': 129, 'hsv_max': 130}
2025-04-14 11:21:37.587 | INFO     | src.rivergame.ammo_test_runner:execute_scenario:52 - å¼€å§‹æ‰§è¡Œæµ‹è¯•åœºæ™¯: Check ammo display
2025-04-14 11:21:37.588 | DEBUG    | src.rivergame.ammo_test_runner:execute_scenario:62 - å¯ç”¨çš„æˆªå›¾æ–‡ä»¶: ['aug_screenShot_100.png', 'aug_screenShot_1000.png', 'aug_screenShot_1100.png', 'aug_screenShot_200.png', 'aug_screenShot_300.png']...    
2025-04-14 11:21:37.588 | DEBUG    | src.rivergame.ammo_test_runner:execute_scenario:65 - æ‰§è¡Œæ­¥éª¤: given - the player has 30 bullets
2025-04-14 11:21:37.588 | DEBUG    | src.rivergame.ammo_test_runner:_execute_step:93 - æ‰§è¡Œæ­¥éª¤ç±»å‹: given, å‚æ•°: {'initial_ammo': 30}
2025-04-14 11:21:37.588 | DEBUG    | src.rivergame.ammo_test_runner:_execute_step:98 - è®¾ç½®åˆå§‹å¼¹è¯æ•°ä¸º: 30
2025-04-14 11:21:37.588 | DEBUG    | src.rivergame.ammo_test_runner:_load_screenshot:212 - å°è¯•åŠ è½½æˆªå›¾: C:\Users\96116\game-testing-main\src\rivergame\../../Code/GameStateChecker\screenShot_3000.png
2025-04-14 11:21:37.635 | INFO     | src.rivergame.ammo_test_runner:_load_screenshot:217 - æˆåŠŸåŠ è½½æˆªå›¾: C:\Users\96116\game-testing-main\src\rivergame\../../Code/GameStateChecker\screenShot_3000.png
2025-04-14 11:21:37.635 | DEBUG    | src.rivergame.ammo_test_runner:_verify_ammo_sync:235 - å¼€å§‹éªŒè¯å¼¹è¯åŒæ­¥ï¼ŒæœŸæœ›å€¼: 30ï¼Œå‚æ•°: {'bbox': [912, 1015, 79, 49], 'hsv_min': 129, 'hsv_max': 130}
2025-04-14 11:21:37.635 | ERROR    | LogicLayer:check_ammo_state:209 - æ£€æµ‹è¿‡ç¨‹å‘ç”Ÿé”™è¯¯: name 'numpy' is not defined
2025-04-14 11:21:37.635 | INFO     | src.rivergame.ammo_test_runner:_verify_ammo_sync:243 - å¼¹è¯éªŒè¯ç»“æœ: (False, "æ£€æµ‹è¿‡ç¨‹é”™è¯¯: name 'numpy' is not defined")
2025-04-14 11:21:37.636 | ERROR    | src.rivergame.ammo_test_runner:execute_scenario:70 - æ­¥éª¤æ‰§è¡Œå¤±è´¥: æœªçŸ¥é”™è¯¯
2025-04-14 11:21:37.636 | INFO     | test_ammo_sync:test_basic_ammo_sync:54 - given: è®¾ç½®åˆå§‹å¼¹è¯æ•°ä¸º: 30
2025-04-14 11:21:37.636 | ERROR    | test_ammo_sync:test_basic_ammo_sync:56 - æ­¥éª¤å¤±è´¥: æœªçŸ¥é”™è¯¯
2025-04-14 11:21:37.636 | ERROR    | test_ammo_sync:test_basic_ammo_sync:61 - æµ‹è¯•æ‰§è¡Œè¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯
Traceback (most recent call last):

  File "C:\Program Files\Python310\lib\runpy.py", line 196, in _run_module_as_main
    return _run_code(code, main_globals, None,
           â”‚         â”‚     â”” {'__name__': '__main__', '__doc__': 'The pytest entry point.', '__package__': 'pytest', '__loader__': <_frozen_importlib_exte...
           â”‚         â”” <code object <module> at 0x000002AD0E0D1790, file "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pytest\__mai...
           â”” <function _run_code at 0x000002AD0D0EE3B0>

  File "C:\Program Files\Python310\lib\runpy.py", line 86, in _run_code
    exec(code, run_globals)
         â”‚     â”” {'__name__': '__main__', '__doc__': 'The pytest entry point.', '__package__': 'pytest', '__loader__': <_frozen_importlib_exte...
         â”” <code object <module> at 0x000002AD0E0D1790, file "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pytest\__mai...

  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pytest\__main__.py", line 9, in <module>
    raise SystemExit(pytest.console_main())
                     â”‚      â”” <function console_main at 0x000002AD0DA53400>
                     â”” <module 'pytest' from 'C:\\Users\\96116\\AppData\\Roaming\\Python\\Python310\\site-packages\\pytest\\__init__.py'>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\_pytest\config\__init__.py", line 201, in console_main
    code = main()
           â”” <function main at 0x000002AD0DA53370>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\_pytest\config\__init__.py", line 175, in main
    ret: ExitCode | int = config.hook.pytest_cmdline_main(config=config)
         â”‚                â”‚      â”‚    â”‚                          â”” <_pytest.config.Config object at 0x000002AD0E0F91B0>
         â”‚                â”‚      â”‚    â”” <HookCaller 'pytest_cmdline_main'>
         â”‚                â”‚      â”” <_pytest.config.compat.PathAwareHookProxy object at 0x000002AD0E0F9300>
         â”‚                â”” <_pytest.config.Config object at 0x000002AD0E0F91B0>
         â”” <enum 'ExitCode'>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pluggy\_hooks.py", line 513, in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           â”‚    â”‚         â”‚    â”‚     â”‚    â”‚                  â”‚       â”” True
           â”‚    â”‚         â”‚    â”‚     â”‚    â”‚                  â”” {'config': <_pytest.config.Config object at 0x000002AD0E0F91B0>}
           â”‚    â”‚         â”‚    â”‚     â”‚    â”” <member '_hookimpls' of 'HookCaller' objects>
           â”‚    â”‚         â”‚    â”‚     â”” <HookCaller 'pytest_cmdline_main'>
           â”‚    â”‚         â”‚    â”” <member 'name' of 'HookCaller' objects>
           â”‚    â”‚         â”” <HookCaller 'pytest_cmdline_main'>
           â”‚    â”” <member '_hookexec' of 'HookCaller' objects>
           â”” <HookCaller 'pytest_cmdline_main'>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pluggy\_manager.py", line 120, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           â”‚    â”‚               â”‚          â”‚        â”‚       â”” True
           â”‚    â”‚               â”‚          â”‚        â”” {'config': <_pytest.config.Config object at 0x000002AD0E0F91B0>}
           â”‚    â”‚               â”‚          â”” [<HookImpl plugin_name='main', plugin=<module '_pytest.main' from 'C:\\Users\\96116\\AppData\\Roaming\\Python\\Python310\\sit...
           â”‚    â”‚               â”” 'pytest_cmdline_main'
           â”‚    â”” <function _multicall at 0x000002AD0D718040>
           â”” <_pytest.config.PytestPluginManager object at 0x000002AD0D0C9DE0>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pluggy\_callers.py", line 103, in _multicall
    res = hook_impl.function(*args)
          â”‚         â”‚         â”” [<_pytest.config.Config object at 0x000002AD0E0F91B0>]
          â”‚         â”” <member 'function' of 'HookImpl' objects>
          â”” <HookImpl plugin_name='main', plugin=<module '_pytest.main' from 'C:\\Users\\96116\\AppData\\Roaming\\Python\\Python310\\site...
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\_pytest\main.py", line 330, in pytest_cmdline_main
    return wrap_session(config, _main)
           â”‚            â”‚       â”” <function _main at 0x000002AD0DAEE7A0>
           â”‚            â”” <_pytest.config.Config object at 0x000002AD0E0F91B0>
           â”” <function wrap_session at 0x000002AD0DAEE680>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\_pytest\main.py", line 283, in wrap_session
    session.exitstatus = doit(config, session) or 0
    â”‚       â”‚            â”‚    â”‚       â”” <Session  exitstatus=<ExitCode.OK: 0> testsfailed=0 testscollected=1>
    â”‚       â”‚            â”‚    â”” <_pytest.config.Config object at 0x000002AD0E0F91B0>
    â”‚       â”‚            â”” <function _main at 0x000002AD0DAEE7A0>
    â”‚       â”” <ExitCode.OK: 0>
    â”” <Session  exitstatus=<ExitCode.OK: 0> testsfailed=0 testscollected=1>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\_pytest\main.py", line 337, in _main
    config.hook.pytest_runtestloop(session=session)
    â”‚      â”‚    â”‚                          â”” <Session  exitstatus=<ExitCode.OK: 0> testsfailed=0 testscollected=1>
    â”‚      â”‚    â”” <HookCaller 'pytest_runtestloop'>
    â”‚      â”” <_pytest.config.compat.PathAwareHookProxy object at 0x000002AD0E0F9300>
    â”” <_pytest.config.Config object at 0x000002AD0E0F91B0>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pluggy\_hooks.py", line 513, in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           â”‚    â”‚         â”‚    â”‚     â”‚    â”‚                  â”‚       â”” True
           â”‚    â”‚         â”‚    â”‚     â”‚    â”‚                  â”” {'session': <Session  exitstatus=<ExitCode.OK: 0> testsfailed=0 testscollected=1>}
           â”‚    â”‚         â”‚    â”‚     â”‚    â”” <member '_hookimpls' of 'HookCaller' objects>
           â”‚    â”‚         â”‚    â”‚     â”” <HookCaller 'pytest_runtestloop'>
           â”‚    â”‚         â”‚    â”” <member 'name' of 'HookCaller' objects>
           â”‚    â”‚         â”” <HookCaller 'pytest_runtestloop'>
           â”‚    â”” <member '_hookexec' of 'HookCaller' objects>
           â”” <HookCaller 'pytest_runtestloop'>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pluggy\_manager.py", line 120, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           â”‚    â”‚               â”‚          â”‚        â”‚       â”” True
           â”‚    â”‚               â”‚          â”‚        â”” {'session': <Session  exitstatus=<ExitCode.OK: 0> testsfailed=0 testscollected=1>}
           â”‚    â”‚               â”‚          â”” [<HookImpl plugin_name='main', plugin=<module '_pytest.main' from 'C:\\Users\\96116\\AppData\\Roaming\\Python\\Python310\\sit...
           â”‚    â”‚               â”” 'pytest_runtestloop'
           â”‚    â”” <function _multicall at 0x000002AD0D718040>
           â”” <_pytest.config.PytestPluginManager object at 0x000002AD0D0C9DE0>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pluggy\_callers.py", line 103, in _multicall
    res = hook_impl.function(*args)
          â”‚         â”‚         â”” [<Session  exitstatus=<ExitCode.OK: 0> testsfailed=0 testscollected=1>]
          â”‚         â”” <member 'function' of 'HookImpl' objects>
          â”” <HookImpl plugin_name='main', plugin=<module '_pytest.main' from 'C:\\Users\\96116\\AppData\\Roaming\\Python\\Python310\\site...
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\_pytest\main.py", line 362, in pytest_runtestloop
    item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)
    â”‚    â”‚                                        â”‚              â”” None
    â”‚    â”‚                                        â”” <Coroutine test_basic_ammo_sync>
    â”‚    â”” <member 'config' of 'Node' objects>
    â”” <Coroutine test_basic_ammo_sync>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pluggy\_hooks.py", line 513, in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           â”‚    â”‚         â”‚    â”‚     â”‚    â”‚                  â”‚       â”” True
           â”‚    â”‚         â”‚    â”‚     â”‚    â”‚                  â”” {'item': <Coroutine test_basic_ammo_sync>, 'nextitem': None}
           â”‚    â”‚         â”‚    â”‚     â”‚    â”” <member '_hookimpls' of 'HookCaller' objects>
           â”‚    â”‚         â”‚    â”‚     â”” <HookCaller 'pytest_runtest_protocol'>
           â”‚    â”‚         â”‚    â”” <member 'name' of 'HookCaller' objects>
           â”‚    â”‚         â”” <HookCaller 'pytest_runtest_protocol'>
           â”‚    â”” <member '_hookexec' of 'HookCaller' objects>
           â”” <HookCaller 'pytest_runtest_protocol'>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pluggy\_manager.py", line 120, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           â”‚    â”‚               â”‚          â”‚        â”‚       â”” True
           â”‚    â”‚               â”‚          â”‚        â”” {'item': <Coroutine test_basic_ammo_sync>, 'nextitem': None}
           â”‚    â”‚               â”‚          â”” [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\96116\\AppData\\Roaming\\Python\\Python310\...
           â”‚    â”‚               â”” 'pytest_runtest_protocol'
           â”‚    â”” <function _multicall at 0x000002AD0D718040>
           â”” <_pytest.config.PytestPluginManager object at 0x000002AD0D0C9DE0>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pluggy\_callers.py", line 103, in _multicall
    res = hook_impl.function(*args)
          â”‚         â”‚         â”” [<Coroutine test_basic_ammo_sync>, None]
          â”‚         â”” <member 'function' of 'HookImpl' objects>
          â”” <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\96116\\AppData\\Roaming\\Python\\Python310\\...
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\_pytest\runner.py", line 113, in pytest_runtest_protocol
    runtestprotocol(item, nextitem=nextitem)
    â”‚               â”‚              â”” None
    â”‚               â”” <Coroutine test_basic_ammo_sync>
    â”” <function runtestprotocol at 0x000002AD0DAEDA20>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\_pytest\runner.py", line 132, in runtestprotocol
    reports.append(call_and_report(item, "call", log))
    â”‚       â”‚      â”‚               â”‚             â”” True
    â”‚       â”‚      â”‚               â”” <Coroutine test_basic_ammo_sync>
    â”‚       â”‚      â”” <function call_and_report at 0x000002AD0DAEDE10>
    â”‚       â”” <method 'append' of 'list' objects>
    â”” [<TestReport 'tests/test_ammo_sync.py::test_basic_ammo_sync' when='setup' outcome='passed'>]
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\_pytest\runner.py", line 241, in call_and_report
    call = CallInfo.from_call(
           â”‚        â”” <classmethod(<function CallInfo.from_call at 0x000002AD0DAEE0E0>)>
           â”” <class '_pytest.runner.CallInfo'>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\_pytest\runner.py", line 341, in from_call
    result: TResult | None = func()
            â”‚                â”” <function call_and_report.<locals>.<lambda> at 0x000002AD41D41AB0>
            â”” +TResult
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\_pytest\runner.py", line 242, in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            â”‚                 â”‚       â”” {}
            â”‚                 â”” <Coroutine test_basic_ammo_sync>
            â”” <HookCaller 'pytest_runtest_call'>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pluggy\_hooks.py", line 513, in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           â”‚    â”‚         â”‚    â”‚     â”‚    â”‚                  â”‚       â”” False
           â”‚    â”‚         â”‚    â”‚     â”‚    â”‚                  â”” {'item': <Coroutine test_basic_ammo_sync>}
           â”‚    â”‚         â”‚    â”‚     â”‚    â”” <member '_hookimpls' of 'HookCaller' objects>
           â”‚    â”‚         â”‚    â”‚     â”” <HookCaller 'pytest_runtest_call'>
           â”‚    â”‚         â”‚    â”” <member 'name' of 'HookCaller' objects>
           â”‚    â”‚         â”” <HookCaller 'pytest_runtest_call'>
           â”‚    â”” <member '_hookexec' of 'HookCaller' objects>
           â”” <HookCaller 'pytest_runtest_call'>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pluggy\_manager.py", line 120, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           â”‚    â”‚               â”‚          â”‚        â”‚       â”” False
           â”‚    â”‚               â”‚          â”‚        â”” {'item': <Coroutine test_basic_ammo_sync>}
           â”‚    â”‚               â”‚          â”” [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\96116\\AppData\\Roaming\\Python\\Python310\...
           â”‚    â”‚               â”” 'pytest_runtest_call'
           â”‚    â”” <function _multicall at 0x000002AD0D718040>
           â”” <_pytest.config.PytestPluginManager object at 0x000002AD0D0C9DE0>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pluggy\_callers.py", line 103, in _multicall
    res = hook_impl.function(*args)
          â”‚         â”‚         â”” [<Coroutine test_basic_ammo_sync>]
          â”‚         â”” <member 'function' of 'HookImpl' objects>
          â”” <HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from 'C:\\Users\\96116\\AppData\\Roaming\\Python\\Python310\\...
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\_pytest\runner.py", line 174, in pytest_runtest_call
    item.runtest()
    â”‚    â”” <function Coroutine.runtest at 0x000002AD0FC585E0>
    â”” <Coroutine test_basic_ammo_sync>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pytest_asyncio\plugin.py", line 549, in runtest
    super().runtest()
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\_pytest\python.py", line 1627, in runtest
    self.ihook.pytest_pyfunc_call(pyfuncitem=self)
    â”‚    â”‚                                   â”” <Coroutine test_basic_ammo_sync>
    â”‚    â”” <property object at 0x000002AD0DA94130>
    â”” <Coroutine test_basic_ammo_sync>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pluggy\_hooks.py", line 513, in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           â”‚    â”‚         â”‚    â”‚     â”‚    â”‚                  â”‚       â”” True
           â”‚    â”‚         â”‚    â”‚     â”‚    â”‚                  â”” {'pyfuncitem': <Coroutine test_basic_ammo_sync>}
           â”‚    â”‚         â”‚    â”‚     â”‚    â”” <member '_hookimpls' of 'HookCaller' objects>
           â”‚    â”‚         â”‚    â”‚     â”” <HookCaller 'pytest_pyfunc_call'>
           â”‚    â”‚         â”‚    â”” <member 'name' of 'HookCaller' objects>
           â”‚    â”‚         â”” <HookCaller 'pytest_pyfunc_call'>
           â”‚    â”” <member '_hookexec' of 'HookCaller' objects>
           â”” <HookCaller 'pytest_pyfunc_call'>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pluggy\_manager.py", line 120, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           â”‚    â”‚               â”‚          â”‚        â”‚       â”” True
           â”‚    â”‚               â”‚          â”‚        â”” {'pyfuncitem': <Coroutine test_basic_ammo_sync>}
           â”‚    â”‚               â”‚          â”” [<HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\96116\\AppData\\Roaming\\Python\\Python310\...
           â”‚    â”‚               â”” 'pytest_pyfunc_call'
           â”‚    â”” <function _multicall at 0x000002AD0D718040>
           â”” <_pytest.config.PytestPluginManager object at 0x000002AD0D0C9DE0>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pluggy\_callers.py", line 103, in _multicall
    res = hook_impl.function(*args)
          â”‚         â”‚         â”” [<Coroutine test_basic_ammo_sync>]
          â”‚         â”” <member 'function' of 'HookImpl' objects>
          â”” <HookImpl plugin_name='python', plugin=<module '_pytest.python' from 'C:\\Users\\96116\\AppData\\Roaming\\Python\\Python310\\...
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\_pytest\python.py", line 159, in pytest_pyfunc_call
    result = testfunction(**testargs)
             â”‚              â”” {'setup_test_environment': {'resources_path': 'C:\\Users\\96116\\game-testing-main\\Code/GameStateChecker', 'default_bbox': [...
             â”” <function test_basic_ammo_sync at 0x000002AD1197DF30>
  File "C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pytest_asyncio\plugin.py", line 1069, in inner
    _loop.run_until_complete(task)
    â”‚     â”‚                  â”” <Task pending name='Task-1' coro=<test_basic_ammo_sync() running at C:\Users\96116\game-testing-main\tests\test_ammo_sync.py:...
    â”‚     â”” <function BaseEventLoop.run_until_complete at 0x000002AD0FBD6E60>
    â”” <ProactorEventLoop running=True closed=False debug=False>

  File "C:\Program Files\Python310\lib\asyncio\base_events.py", line 636, in run_until_complete
    self.run_forever()
    â”‚    â”” <function ProactorEventLoop.run_forever at 0x000002AD0FC21360>
    â”” <ProactorEventLoop running=True closed=False debug=False>

  File "C:\Program Files\Python310\lib\asyncio\windows_events.py", line 321, in run_forever
    super().run_forever()

  File "C:\Program Files\Python310\lib\asyncio\base_events.py", line 603, in run_forever
    self._run_once()
    â”‚    â”” <function BaseEventLoop._run_once at 0x000002AD0FBD8940>
    â”” <ProactorEventLoop running=True closed=False debug=False>

  File "C:\Program Files\Python310\lib\asyncio\base_events.py", line 1906, in _run_once
    handle._run()
    â”‚      â”” <function Handle._run at 0x000002AD0E3B4310>
    â”” <Handle <TaskStepMethWrapper object at 0x000002AD41D2EA70>()>

  File "C:\Program Files\Python310\lib\asyncio\events.py", line 80, in _run
    self._context.run(self._callback, *self._args)
    â”‚    â”‚            â”‚    â”‚           â”‚    â”” <member '_args' of 'Handle' objects>
    â”‚    â”‚            â”‚    â”‚           â”” <Handle <TaskStepMethWrapper object at 0x000002AD41D2EA70>()>
    â”‚    â”‚            â”‚    â”” <member '_callback' of 'Handle' objects>
    â”‚    â”‚            â”” <Handle <TaskStepMethWrapper object at 0x000002AD41D2EA70>()>
    â”‚    â”” <member '_context' of 'Handle' objects>
    â”” <Handle <TaskStepMethWrapper object at 0x000002AD41D2EA70>()>

> File "C:\Users\96116\game-testing-main\tests\test_ammo_sync.py", line 58, in test_basic_ammo_sync
    assert results['success'], f"æµ‹è¯•æ‰§è¡Œå¤±è´¥: {results.get('error', 'æœªçŸ¥é”™è¯¯')}"
           â”” {'scenario_name': 'Check ammo display', 'steps_results': [{'type': 'given', 'message': 'è®¾ç½®åˆå§‹å¼¹è¯æ•°ä¸º: 30', 'success': False}], 's...

AssertionError: æµ‹è¯•æ‰§è¡Œå¤±è´¥: æœªçŸ¥é”™è¯¯
assert False
-------------------------------------------------------------------------------------------------------------- Captured log teardown --------------------------------------------------------------------------------------------------------------- 
DEBUG    asyncio:proactor_events.py:630 Using proactor: IocpProactor
================================================================================================================= warnings summary ================================================================================================================= 
..\AppData\Roaming\Python\Python310\site-packages\pytest_asyncio\plugin.py:272
  C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pytest_asyncio\plugin.py:272: PytestDeprecationWarning: mock_game_server is asynchronous and explicitly requests the "event_loop" fixture. Asynchronous fixtures and test functions should use "asyncio.get_running_loop()" instead.
    warnings.warn(

tests/test_ammo_sync.py::test_basic_ammo_sync
  C:\Users\96116\AppData\Roaming\Python\Python310\site-packages\pytest_asyncio\plugin.py:884: DeprecationWarning: The event_loop fixture provided by pytest-asyncio has been redefined in
  C:\Users\96116\game-testing-main\tests\conftest.py:17
  Replacing the event_loop fixture with a custom implementation is deprecated
  and will lead to errors in the future.
  If you want to request an asyncio event loop with a scope other than function
  scope, use the "loop_scope" argument to the asyncio mark when marking the tests.
  If you want to return different types of event loops, use the event_loop_policy
  fixture.

    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
============================================================================================================= short test summary info ============================================================================================================== 
FAILED tests/test_ammo_sync.py::test_basic_ammo_sync - AssertionError: æµ‹è¯•æ‰§è¡Œå¤±è´¥: æœªçŸ¥é”™è¯¯
========================================================================================================== 1 failed, 2 warnings in 0.64s =========================================================================================================== 
PS C:\Users\96116\game-testing-main> 
æ­£åœ¨æ”¶é›†å·¥ä½œåŒºä¿¡æ¯# OpenAI API è°ƒç”¨ä¸æ¨¡å‹å‡çº§æŒ‡å—

æ‚¨çš„ä»£ç ä¸­å­˜åœ¨å¤šå¤„ API è°ƒç”¨é—®é¢˜ï¼Œéœ€è¦ç»Ÿä¸€æ›´æ–°ä¸º GPT-4o æ¨¡å‹å¹¶ä¼˜åŒ–è°ƒç”¨æ–¹å¼ã€‚æˆ‘å‘ç°æœ‰å‡ ä¸ªä¸»è¦é—®é¢˜ï¼š

1. **GPT æ¨¡å‹ç¡¬ç¼–ç ä¸º GPT-4**
2. **API è°ƒç”¨æ–¹å¼æ··ç”¨**ï¼ˆè€ç‰ˆæœ¬ SDK ä¸æ–°ç‰ˆæœ¬ AsyncOpenAI å®¢æˆ·ç«¯ï¼‰
3. **ç¼ºå°‘å¿…è¦ä¾èµ–**ï¼ˆæµ‹è¯•é”™è¯¯æ˜¾ç¤º `name 'numpy' is not defined`ï¼‰
4. **é…ç½®æ–‡ä»¶ç¼–ç é—®é¢˜**ï¼ˆGBK è§£ç é”™è¯¯ï¼‰

## è§£å†³æ–¹æ¡ˆ

### 1. åˆ›å»ºæµ‹è¯•æ–‡ä»¶éªŒè¯ API è¿æ¥

````python
import os
from dotenv import load_dotenv
from openai import OpenAI

# åŠ è½½ç¯å¢ƒå˜é‡
load_dotenv()

# è·å–æ¨¡å‹åç§°ï¼ˆé»˜è®¤ä¸ºgpt-4oï¼‰
MODEL_NAME = os.getenv("OPENAI_MODEL", "gpt-4o")

def test_connection():
    # åˆ›å»ºå®¢æˆ·ç«¯
    client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
    
    try:
        # æµ‹è¯•APIè°ƒç”¨
        response = client.chat.completions.create(
            model=MODEL_NAME,
            messages=[
                {"role": "system", "content": "ä½ æ˜¯ä¸€ä¸ªæ¸¸æˆæµ‹è¯•åŠ©æ‰‹"},
                {"role": "user", "content": "è¿”å›'APIè¿æ¥æˆåŠŸ'"}
            ],
            max_tokens=10
        )
        print(f"APIè°ƒç”¨æˆåŠŸï¼ä½¿ç”¨æ¨¡å‹: {MODEL_NAME}")
        print(f"å“åº”å†…å®¹: {response.choices[0].message.content}")
        return True
    except Exception as e:
        print(f"APIè°ƒç”¨å¤±è´¥: {str(e)}")
        return False

if __name__ == "__main__":
    test_connection()
````

### 2. ä¿®å¤ `GPTClient` ç±»

````python
import os
import yaml
from openai import AsyncOpenAI
from dotenv import load_dotenv

class GPTClient:
    def __init__(self, config_path: str = "config.yaml"):
        # åŠ è½½ç¯å¢ƒå˜é‡
        load_dotenv()
        
        # ä»ç¯å¢ƒå˜é‡è·å–APIå¯†é’¥
        api_key = os.getenv("OPENAI_API_KEY")
        
        # åŠ è½½é…ç½®
        try:
            with open(config_path, "r", encoding="utf-8") as f:  # æ˜ç¡®æŒ‡å®šUTF-8ç¼–ç 
                config = yaml.safe_load(f)
                
            # è®¾ç½®æ¨¡å‹å‚æ•°
            self.model = os.getenv("OPENAI_MODEL", config["api"]["openai"]["model"])
            self.temperature = config["api"]["openai"]["temperature"]
            self.max_tokens = config["api"]["openai"]["max_tokens"]
        except Exception as e:
            print(f"é…ç½®åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼: {e}")
            self.model = os.getenv("OPENAI_MODEL", "gpt-4o")  # é»˜è®¤ä½¿ç”¨gpt-4o
            self.temperature = 0.7
            self.max_tokens = 1000
        
        # åˆå§‹åŒ–å®¢æˆ·ç«¯
        self.client = AsyncOpenAI(api_key=api_key)
    
    async def generate_test_scenario(self, prompt: str) -> str:
        """è°ƒç”¨GPTç”Ÿæˆæµ‹è¯•åœºæ™¯"""
        try:
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": "ä½ æ˜¯ä¸€ä¸ªæ¸¸æˆæµ‹è¯•ä¸“å®¶..."},
                    {"role": "user", "content": prompt}
                ],
                temperature=self.temperature,
                max_tokens=self.max_tokens
            )
            return response.choices[0].message.content
        except Exception as e:
            print(f"GPT APIè°ƒç”¨å¤±è´¥: {e}")
            return None
````

### 3. æ›´æ–° config.yaml æ–‡ä»¶

````yaml
api:
  openai:
    model: gpt-4o
    temperature: 0.7
    max_tokens: 1000
  
rivergame:
  host: "localhost"
  port: 8080
  
logging:
  level: INFO
  file: "logs/app.log"
````

### 4. ä¿®å¤æµ‹è¯•é”™è¯¯

ä»æµ‹è¯•æ—¥å¿—çœ‹ï¼Œæ‚¨ç¼ºå°‘ `numpy` åº“ã€‚æ‚¨éœ€è¦å®‰è£…å®ƒå¹¶æ›´æ–° requirements.txtï¼š

````python
# å·²æœ‰çš„ä¾èµ–
openai>=1.14.0
python-dotenv>=1.0.0
pyyaml>=6.0
pytest>=7.0.0
pytest-asyncio>=0.20.0
# æ·»åŠ çš„ä¾èµ–
numpy>=1.22.0
# å…¶ä»–ä¾èµ–...
````

## æ‰§è¡Œæ­¥éª¤

1. å®‰è£…æˆ–æ›´æ–°ä¾èµ–ï¼š
   ```bash
   pip install -r requirements.txt
   ```

2. åˆ›å»ºæˆ–æ›´æ–° .env æ–‡ä»¶ï¼š
   ```
   OPENAI_API_KEY=sk-your-key-here
   OPENAI_MODEL=gpt-4o
   ```

3. è¿è¡Œæµ‹è¯•è¿æ¥è„šæœ¬ï¼š
   ```bash
   python test_api_connection.py
   ```

4. å¦‚æœè¿æ¥æˆåŠŸï¼Œå†å°è¯•è¿è¡Œæ‚¨çš„æµ‹è¯•ï¼š
   ```bash
   pytest tests/test_ammo_sync.py -v
   ```

## æ³¨æ„äº‹é¡¹

1. `numpy` æœªå®šä¹‰çš„é”™è¯¯è¡¨æ˜æ‚¨éœ€è¦åœ¨ Python ç¯å¢ƒä¸­å®‰è£… NumPy
2. é…ç½®æ–‡ä»¶ç¼–ç é”™è¯¯è¡¨æ˜éœ€è¦ä½¿ç”¨ UTF-8 æ‰“å¼€æ–‡ä»¶
3. æ¨¡å‹åç§°æ”¹ä¸º `gpt-4o` åï¼Œè¯·ç¡®è®¤æ‚¨çš„è´¦å·æœ‰æƒé™è®¿é—®è¯¥æ¨¡å‹

è¿™æ ·ç»Ÿä¸€æ”¹é€ åï¼Œæ‚¨çš„ä»£ç å°†æ›´åŠ å¥å£®ï¼Œä¸”èƒ½ä½¿ç”¨æœ€æ–°çš„ GPT-4o æ¨¡å‹ã€‚