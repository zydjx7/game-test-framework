# Gherkin 测试执行框架分析

我已经分析了您项目的代码结构，下面我将对 Gherkin → 测试执行的完整流程进行说明。

## 1. 整体框架结构

项目分为几个主要部分：

1. **LLM 生成模块**：负责调用 OpenAI API 生成 Gherkin 测试用例
2. **Gherkin 解析模块**：负责解析和验证 Gherkin 格式的测试用例
3. **测试执行模块**：执行 Gherkin 测试用例并与游戏交互
4. **视觉验证模块**：处理游戏截图和视觉检测

## 2. Gherkin → 测试执行的完整流程

### 入口点：`run_tests.py`

run_tests.py 是测试执行的主要入口，提供了三种执行模式：

```python
# 1. 预定义测试模式
run_predefined_tests()  # 运行 features/ 中已有的 Gherkin 文件

# 2. 生成单个测试模式
run_generated_tests(api_key, requirement)  # 根据需求生成一个测试用例并执行

# 3. 批量生成测试模式
run_batch_tests(api_key, requirement, count)  # 生成多个测试用例并执行
```

### LLM 生成 Gherkin 测试用例

llm_generator.py 中的 `TestGenerator` 类负责生成测试用例：

```python
class TestGenerator:
    def generate_test_case(self, requirement):
        # 根据需求调用 OpenAI API 生成 Gherkin 格式的测试用例
        # 返回 Gherkin 文本
```

生成的 Gherkin 测试用例会被保存到 `.feature` 文件中：

```python
# Code/bdd/test_generator/test_executor.py
feature_path = os.path.join(self.feature_dir, 'generated_test.feature')
with open(feature_path, 'w', encoding='utf-8') as f:
    f.write(gherkin_test)
```

### Gherkin 解析

parser.py 中的 `GherkinParser` 类负责解析和验证 Gherkin 格式：

```python
class GherkinParser:
    def parse_feature(self, content: str):
        # 解析 Gherkin 内容，提取 Feature, Scenario 和 Steps
    
    def validate_gherkin(self, content: str):
        # 验证 Gherkin 语法是否正确
        
    def _extract_params(self, step_type: str, content: str):
        # 提取步骤中的参数
```

### 测试执行

根据您使用的特定场景（弹药测试），主要由 ammo_test_runner.py 中的 `AmmoTestRunner` 类负责执行测试：

```python
class AmmoTestRunner:
    async def execute_scenario(self, scenario):
        # 执行整个测试场景
        
    async def _execute_step(self, step):
        # 执行单个测试步骤
        # 根据步骤类型 (given/when/then) 和参数执行相应的操作
```

对于通用的测试执行，项目使用 test_runner.py 中的 `RiverGameTestRunner` 类：

```python
class RiverGameTestRunner:
    async def execute_test_scenario(self, scenario):
        # 执行测试场景
        
    async def _execute_step(self, step):
        # 根据步骤类型执行相应的操作
```

### 视觉验证

视觉验证由以下组件负责：

1. **LogicLayer**：`Code/GameStateChecker/LogicLayer.py` 提供了验证功能，如 `testAmmoTextInSync` 方法用于检查弹药计数是否与预期值匹配。

2. **VisionUtils**：`Code/GameStateChecker/VisionUtils.py` 提供了图像处理功能，如 OCR 识别文本。

3. **视觉参数**：对于弹药测试，关键参数包括：
   - 图像区域 (bbox)
   - 文本颜色 HSV 范围
   - 期望的弹药数量

## 3. 关键代码示例：Gherkin → 测试执行的完整路径

### 1. 生成/解析 Gherkin 测试用例

```python
# 1. 使用 TestGenerator 生成 Gherkin 文本
gherkin_text = test_generator.generate_test_case("测试武器弹药系统")

# 2. 解析 Gherkin 文本为结构化数据
parser = GherkinParser()
feature = parser.parse_feature(gherkin_text)
```

### 2. 执行测试场景

```python
# 创建测试执行器
runner = AmmoTestRunner()

# 执行测试场景
results = await runner.execute_scenario(feature['scenarios'][0])
```

### 3. 执行单个步骤

```python
# Given 步骤：设置初始弹药数
if step_type == 'given' and 'initial_ammo' in params:
    self._current_ammo = params['initial_ammo']
    screenshot = self._load_screenshot(self._current_ammo)
    # 验证初始弹药数是否显示正确

# When 步骤：发射子弹
elif step_type == 'when' and 'shots' in params:
    shots = params['shots']
    self._current_ammo = max(0, self._current_ammo - shots)
    screenshot = self._load_screenshot(self._current_ammo)

# Then 步骤：验证弹药数是否正确
elif step_type == 'then' and 'expected_ammo' in params:
    expected = params['expected_ammo']
    is_sync = self._verify_ammo_sync(screenshot, expected)
```

### 4. 视觉验证

```python
def _verify_ammo_sync(self, screenshot, expected_ammo):
    # 调用 LogicLayer 进行视觉验证
    result = self._logic_layer.testAmmoTextInSync(
        screenshots=[screenshot],
        context={
            "bbox": self._vision_params.get('bbox'),
            "textColorValueInHSV_min": self._vision_params.get('color_hsv_min'),
            "textColorValueInHSV_max": self._vision_params.get('color_hsv_max')
        },
        expectedAnswer={"intResult": expected_ammo},
        debugEnabled=self._debug_mode
    )
    return result
```

## 4. 典型的 Gherkin 测试场景示例

```gherkin
Feature: Weapon Ammo System

  Scenario: Firing weapon should decrease ammo count
    Given the player has 30 bullets
    When the player shoots once
    Then the ammo displayed should be 29
```

这个测试场景在系统中的处理流程：

1. **解析**：`GherkinParser` 将场景解析为具有参数的步骤
   - `given` 步骤参数: `{'initial_ammo': 30}`
   - `when` 步骤参数: `{'shots': 1}`
   - `then` 步骤参数: `{'expected_ammo': 29}`

2. **执行**：`AmmoTestRunner` 按顺序执行每个步骤
   - 设置初始弹药为 30
   - 模拟发射 1 发子弹，将弹药数减少到 29
   - 验证屏幕上显示的弹药数是否为 29

3. **验证**：使用 `LogicLayer.testAmmoTextInSync()` 检查游戏截图中的弹药数是否与预期值匹配

## 5. 缺失的环节和挑战

1. **截图获取**：项目依赖于预先准备的截图，而不是实时从游戏获取，这可能需要适当的截图命名约定。

2. **Gherkin 步骤匹配**：需要确保 LLM 生成的步骤与预定义的步骤模式匹配。

3. **异步执行**：大部分测试执行逻辑是异步的，需要确保正确的事件循环管理。

要成功跑通 Gherkin → 测试执行的流程，需要确保以上所有组件正确配置并且互相配合。截图和视觉逻辑是其中的关键部分，因为它们负责验证游戏状态是否符合预期。