<!-- Generated by SpecStory -->

# 项目框架与测试目标详解 (2025-04-20 08:55:43)

_**User**_

请浏览项目整体框架，对核心部分做出详细说明，包括定义的不同测试目标的使用方法，检测逻辑......

---

_**Assistant**_



---

好的，我们先来浏览一下项目的整体文件结构，以便了解其组织方式。



---

<details>
            <summary>Listed current directory • **38** results</summary>
        
| Name |
|-------|
| 📁 `.git` |
| 📄 `test_debug.log` |
| 📄 `CHANGELOG.md` |
| 📄 `test_debug.2025-04-19_20-20-04_497123.log` |
| 📄 `test_debug.2025-04-19_19-57-29_068375.log` |
| 📄 `test_debug.2025-04-19_19-27-32_138082.log` |
| 📄 `test_debug.2025-04-19_18-34-37_126307.log` |
| 📁 `Code` |
| 📁 `NOTEPAD` |
| 📄 `test_debug.2025-04-19_17-07-26_188839.log` |
| 📄 `test_debug.2025-04-19_14-49-05_504270.log` |
| 📁 `debug` |
| 📄 `test_debug.2025-04-18_22-30-09_003513.log` |
| 📄 `[master 5190ddb] 优化游戏状态检测系统：改进弹药检测和调试结构` |
| 📄 `h origin master` |
| 📄 `config.yaml` |
| 📄 `test_debug.2025-04-18_09-51-15_921441.log` |
| 📄 `setup.py` |
| 📁 `game_testing.egg-info` |
| 📁 `logs` |
| 📄 `tatus` |
| 📄 `requirements.txt` |
| 📄 `.env` |
| 📄 `.gitignore` |
| 📄 `pytest.ini` |
| 📄 `debug_binary.png` |
| 📄 `debug_roi.png` |
| 📁 `tests` |
| 📁 `src` |
| 📁 `.pytest_cache` |
| 📁 `results` |
| 📁 `features` |
| 📁 `.vs` |
| 📁 `.github` |
| 📁 `.idea` |
| 📁 `.ipynb_checkpoints` |
| 📁 `Doc` |
| 📄 `README.md` |

</details>

---

从根目录结构来看，核心代码可能位于 `src/` 目录下。此外，`tests/` 目录包含了测试代码，`config.yaml` 可能是配置文件，`features/` 可能包含测试场景或特性定义，`logs/` 和 `results/` 用于存放日志和结果。

接下来，我们深入 `src/` 目录看看。



---

<details>
            <summary>Listed directory src • **7** results</summary>
        
| Name |
|-------|
| 📁 `__pycache__` |
| 📄 `main.py` |
| 📄 `__init__.py` |
| 📁 `llm` |
| 📁 `rivergame` |
| 📁 `utils` |
| 📁 `gherkin` |

</details>

---



---

`src/` 目录包含了项目的核心逻辑。
*   `main.py` 看起来是主入口文件。
*   `rivergame/` 目录可能包含了与游戏测试直接相关的代码。
*   `llm/` 目录可能与大型语言模型交互有关。
*   `utils/` 目录包含通用工具函数。
*   `gherkin/` 目录暗示项目可能使用了 Gherkin 语法（通常与 BDD 框架如 Behave 或 Cucumber 结合使用）来描述测试场景，这可能与根目录下的 `features/` 目录有关。

我们先看看 `src/rivergame/` 里面有什么。



---

<details>
            <summary>Listed directory src/rivergame • **5** results</summary>
        
| Name |
|-------|
| 📄 `ammo_test_runner.py` |
| 📁 `__pycache__` |
| 📄 `mock_server.py` |
| 📄 `test_runner.py` |
| 📄 `__init__.py` |

</details>

---



---

`src/rivergame/` 目录包含测试执行的核心逻辑：
*   `test_runner.py`: 通用的测试执行器。
*   `ammo_test_runner.py`: 可能是针对特定测试目标（例如弹药检测）的执行器。
*   `mock_server.py`: 可能用于模拟外部服务或游戏组件。

现在，我们看一下 `src/llm/` 目录。



---

<details>
            <summary>Listed directory src/llm • **4** results</summary>
        
| Name |
|-------|
| 📄 `gpt_client.py` |
| 📁 `__pycache__` |
| 📄 `ammo_scenario_generator.py` |
| 📄 `__init__.py` |

</details>

---



---

`src/llm/` 目录包含与 LLM 交互的代码：
*   `gpt_client.py`: 用于与 GPT 模型进行交互的客户端。
*   `ammo_scenario_generator.py`: 可能使用 LLM 来生成弹药相关的测试场景。

接下来，我们查看一下 `src/utils/` 目录。



---

<details>
            <summary>Listed directory src/utils • **3** results</summary>
        
| Name |
|-------|
| 📁 `__pycache__` |
| 📄 `config.py` |
| 📄 `__init__.py` |

</details>

---



---

`src/utils/` 目录目前只包含 `config.py` 文件，这表明它负责加载和管理项目的配置（可能来自根目录的 `config.yaml`）。

现在我们来看看 `features/` 目录，了解测试场景是如何定义的。



---

<details>
            <summary>Listed directory features • **0** results</summary>
        
No results found
</details>

---



---

`features/` 目录是空的。这有点奇怪，因为 `src/gherkin/` 的存在暗示了 Gherkin 特性文件应该在这里。也许测试场景是通过其他方式定义的，或者这个目录目前未被使用。

我们现在需要看一下核心的实现代码来理解测试目标和检测逻辑。`src/rivergame/ammo_test_runner.py` 文件名暗示了它可能包含了弹药检测相关的逻辑。我们来读取这个文件的内容。



---

Read file: src/rivergame/ammo_test_runner.py

---



---

好的，我们已经查看了 `src/rivergame/ammo_test_runner.py` 的内容。以下是一些关键发现：

1.  **核心检测逻辑分离**：实际的游戏状态检测（例如弹药数量）并不在这个文件里实现。它导入并使用了 `Code/GameStateChecker/LogicLayer.py` 中的 `LogicLayer` 类。这表明核心的视觉识别和状态判断逻辑位于项目根目录下的 `Code/` 文件夹内。
2.  **测试目标（弹药检测）**：
    *   此类专门用于测试弹药 (`Ammo`) 状态。
    *   它通过维护一个内部的 `_current_ammo` 状态来模拟游戏中的弹药变化。
    *   测试依赖于预先准备好的游戏截图。`_load_screenshot` 方法根据预期的弹药数量加载对应的截图文件（例如 `screenShot_3000.png` 代表 30 弹药，或者 `screenShot_5.png` 代表 5 弹药）。这些截图似乎存放在 `Code/GameStateChecker/` 目录下。
    *   测试场景 (`scenario`) 包含一系列步骤 (`given`, `when`, `then`)：
        *   `given`: 设置初始弹药状态，并加载对应截图进行验证。
        *   `when`: 模拟射击动作，减少内部弹药计数。
        *   `then`: 加载当前弹药数对应的截图，调用 `_verify_ammo_sync` 方法进行验证。
3.  **检测逻辑 (`_verify_ammo_sync`)**：
    *   此方法负责调用 `LogicLayer` 的 `check_ammo_state` 方法。
    *   它将加载的截图、期望的弹药数以及视觉检测参数（如截图中的特定区域 `bbox`）传递给 `LogicLayer` 进行实际的图像分析和状态判断。
    *   视觉参数（边界框 `bbox`、HSV 颜色范围 `hsv_min`, `hsv_max`）可以在运行时通过 `setup_vision_params` 方法设置，或者使用默认值。

**总结项目结构（到目前为止）：**

*   **入口与编排**: `src/main.py` (可能)
*   **测试执行器**:
    *   `src/rivergame/test_runner.py` (通用)
    *   `src/rivergame/ammo_test_runner.py` (弹药测试专用)
*   **核心检测逻辑**: `Code/GameStateChecker/LogicLayer.py` (包含 `check_ammo_state` 等)
*   **测试数据**: 游戏截图存储在 `Code/GameStateChecker/` 目录下。
*   **场景生成/定义**: 可能由 `src/llm/ammo_scenario_generator.py` 生成，或者原本设计从 `features/` 加载。
*   **配置**: `config.yaml` (根目录), 由 `src/utils/config.py` 加载。
*   **LLM 集成**: `src/llm/gpt_client.py`

**下一步：**

为了深入理解检测逻辑，我们需要查看 `Code/GameStateChecker/LogicLayer.py` 的内容。我们先列出 `Code/GameStateChecker/` 目录的内容。



---

<details>
            <summary>Listed directory Code/GameStateChecker • **100** results</summary>
        
| Name |
|-------|
| 📄 `LogicLayer.py` |
| 📁 `__pycache__` |
| 📄 `config.yaml` |
| 📄 `VisionUtils.py` |
| 📄 `AmmoTemplateRecognizer.py` |
| 📄 `test_debug.log` |
| 📄 `main_flask_server.py` |
| 📁 `debug` |
| 📁 `templates` |
| 📁 `test_images` |
| 📄 `main_flask_client.py` |
| 📄 `debug_roi.png` |
| 📄 `main_client_proxy.py` |
| 📁 `unitTestResources` |
| 📄 `aug_screenShot_100.png` |
| 📄 `aug_screenShot_1000.png` |
| 📄 `aug_screenShot_1100.png` |
| 📄 `aug_screenShot_200.png` |
| 📄 `aug_screenShot_300.png` |
| 📄 `aug_screenShot_400.png` |
| 📄 `aug_screenShot_500.png` |
| 📄 `aug_screenShot_600.png` |
| 📄 `aug_screenShot_700.png` |
| 📄 `aug_screenShot_800.png` |
| 📄 `aug_screenShot_900.png` |
| 📄 `screenShot_100 - Copy.png` |
| 📄 `screenShot_100.png` |
| 📄 `screenShot_1000.png` |
| 📄 `screenShot_1100.png` |
| 📄 `screenShot_1200.png` |
| 📄 `screenShot_1300.png` |
| 📄 `screenShot_1400.png` |
| 📄 `screenShot_1500.png` |
| 📄 `screenShot_1600.png` |
| 📄 `screenShot_1700.png` |
| 📄 `screenShot_1800.png` |
| 📄 `screenShot_1900.png` |
| 📄 `screenShot_200.png` |
| 📄 `screenShot_2000.png` |
| 📄 `screenShot_2100.png` |
| 📄 `screenShot_2200.png` |
| 📄 `screenShot_2300.png` |
| 📄 `screenShot_2400.png` |
| 📄 `screenShot_2500.png` |
| 📄 `screenShot_2600.png` |
| 📄 `screenShot_2700.png` |
| 📄 `screenShot_2800.png` |
| 📄 `screenShot_2900.png` |
| 📄 `screenShot_300.png` |
| 📄 `screenShot_3000.png` |
| 📄 `screenShot_3100.png` |
| 📄 `screenShot_3200.png` |
| 📄 `screenShot_3300.png` |
| 📄 `screenShot_3400.png` |
| 📄 `screenShot_3500.png` |
| 📄 `screenShot_3600.png` |
| 📄 `screenShot_3700.png` |
| 📄 `screenShot_3800.png` |
| 📄 `screenShot_3900.png` |
| 📄 `screenShot_400.png` |
| 📄 `screenShot_4000.png` |
| 📄 `screenShot_4100.png` |
| 📄 `screenShot_4200.png` |
| 📄 `screenShot_4300.png` |
| 📄 `screenShot_4400.png` |
| 📄 `screenShot_4500.png` |
| 📄 `screenShot_4600.png` |
| 📄 `screenShot_4700.png` |
| 📄 `screenShot_4800.png` |
| 📄 `screenShot_4900.png` |
| 📄 `screenShot_500.png` |
| 📄 `screenShot_5000.png` |
| 📄 `screenShot_5100.png` |
| 📄 `screenShot_5200.png` |
| 📄 `screenShot_5300.png` |
| 📄 `screenShot_5400.png` |
| 📄 `screenShot_5500.png` |
| 📄 `screenShot_5600.png` |
| 📄 `screenShot_5700.png` |
| 📄 `screenShot_5800.png` |
| 📄 `screenShot_5900.png` |
| 📄 `screenShot_600.png` |
| 📄 `screenShot_6000.png` |
| 📄 `screenShot_6100.png` |
| 📄 `screenShot_6200.png` |
| 📄 `screenShot_6300.png` |
| 📄 `screenShot_6400.png` |
| 📄 `screenShot_6500.png` |
| 📄 `screenShot_6600.png` |
| 📄 `screenShot_6700.png` |
| 📄 `screenShot_6800.png` |
| 📄 `screenShot_6900.png` |
| 📄 `screenShot_700.png` |
| 📄 `screenShot_7000.png` |
| 📄 `screenShot_7100.png` |
| 📄 `screenShot_7200.png` |
| 📄 `screenShot_7300.png` |
| 📄 `screenShot_7400.png` |
| 📄 `screenShot_7500.png` |
| 📄 `screenShot_7600.png` |

</details>

---



---

`Code/GameStateChecker/` 目录包含了核心的游戏状态检测逻辑和相关文件：

*   `LogicLayer.py`: 这是我们之前追踪到的核心逻辑层文件，很可能包含了各种状态检测方法（如 `check_ammo_state`）。
*   `VisionUtils.py`: 包含图像处理和视觉分析的通用工具函数。
*   `AmmoTemplateRecognizer.py`: 专门用于识别弹药数字或图标的模板匹配识别器。这很可能是 `check_ammo_state` 内部使用的关键组件。
*   `config.yaml`: GameStateChecker 模块自身的配置文件。
*   `main_flask_server.py` 和 `main_flask_client.py`: 表明 GameStateChecker 也可以作为一个独立的 Flask 服务运行和被调用。
*   `templates/` 和 `test_images/`: 可能包含模板图像和用于测试的图像。
*   大量的 `screenShot_*.png` 和 `aug_screenShot_*.png` 文件: 这些就是 `AmmoTestRunner` 加载的截图，用于模拟不同的游戏状态。

现在，我们将读取 `LogicLayer.py` 文件，了解其内部实现，特别是 `check_ammo_state` 方法。由于文件较大（804 行），我们先读取前 250 行。



---

Read file: Code/GameStateChecker/LogicLayer.py

---



---

从 `LogicLayer.py` 的前 250 行可以看出：

*   **配置驱动**: `LogicLayer` 严重依赖于 `config.yaml` 文件来配置不同的测试目标 (`targets`)，包括截图路径、视觉参数（如模板路径、区域、阈值等）。
*   **目标特定参数**: 可以为不同的游戏或测试目标（如 `p1_legacy`）定义不同的参数集。
*   **视觉工具**: 它导入并使用了 `VisionUtils.py`，这表明具体的图像处理算法（如模板匹配 `matchTemplateImg`）是在 `VisionUtils` 中实现的。
*   **测试方法**: 文件定义了诸如 `testWeaponCrossPresence`（测试准星是否存在）和 `testAmmoTextInSync`（测试弹药文本同步）等方法。这些方法接收截图、上下文、预期结果和可选的视觉参数作为输入。
*   **调试**: 方法普遍包含 `debugEnabled` 和 `debug_dir` 参数，用于输出中间结果和保存调试图像。

根据文件概要，`check_ammo_state` 方法大约在第 402 行开始。现在我们来读取这部分内容，以了解具体的弹药检测逻辑。



---

Read file: Code/GameStateChecker/LogicLayer.py

---



---

`check_ammo_state` 方法的实现细节如下：

1.  **输入**: 接收截图（可以是文件路径或 NumPy 图像数组）、期望的弹药值 (`expected_value`)、可选的检测区域 (`region`) 和视觉参数 (`cv_params`)。
2.  **模板匹配优先**:
    *   它首先尝试使用 `AmmoTemplateRecognizer` (来自 `AmmoTemplateRecognizer.py`) 进行模板匹配来识别弹药数字。
    *   `AmmoTemplateRecognizer` 使用 `Code/GameStateChecker/templates/digits/` 目录下的模板图像。
    *   如果模板匹配成功并且结果可信 (`is_confident`)，则直接返回匹配结果，不再进行后续处理。
3.  **OCR 备选**:
    *   如果模板匹配失败或结果不可信，则回退到使用 OCR（光学字符识别）方法。
    *   **区域提取 (ROI)**:
        *   确定弹药数字所在的区域。优先使用传入的 `region` 参数。
        *   如果没有传入 `region`，则尝试从 `cv_params` 获取相对坐标 `ammo_bbox_rel` 并计算绝对坐标。它会根据期望值是否大于等于 10 来调整区域宽度。
        *   如果也没有相对坐标，则使用硬编码的绝对坐标（区分单位数和双位数），但会发出警告，因为这可能不适用于所有分辨率。
        *   提取 ROI 图像。
    *   **图像预处理**: 将 ROI 转换为灰度图，然后进行二值化处理（`cv2.threshold`），以增强数字的对比度。
    *   **特殊处理 (0)**: 如果期望值为 0，它会尝试使用模板匹配（可能加载 `templates/zero.png`）来检测 0，而不是依赖 OCR。
    *   **OCR 识别**: 使用 `pytesseract` 库对预处理后的 ROI 图像进行 OCR。它限制了识别的字符集为数字 (`0123456789`) 并使用页面分割模式 7 (`--psm 7`)，这通常适用于单个文本行。
    *   **结果比较**: 将 OCR 识别出的数字与 `expected_value` 进行比较，并返回结果。
4.  **返回**: 返回一个元组 `(bool, str)`，表示检测结果是否与期望值匹配，以及一条包含详细信息的字符串。

**总结核心检测逻辑 (弹药):**

弹药检测采用混合策略：

1.  **优先使用模板匹配**: 利用 `AmmoTemplateRecognizer` 对数字模板进行匹配，这种方法对于字体、大小固定的数字通常更稳定、更快速。
2.  **OCR 作为备选**: 当模板匹配效果不佳或失败时，使用通用的 OCR 技术 (`pytesseract`) 进行识别。这提供了更强的泛化能力，但可能对图像质量、字体变化更敏感。
3.  **区域定位**: 需要准确定义弹药数字在屏幕上的位置（ROI），可以通过配置（绝对/相对坐标）或硬编码实现。
4.  **预处理**: 通过灰度化和二值化来简化图像，提高识别准确率。

**项目整体框架总结:**

*   **目标**: 自动化测试游戏内状态（目前主要是弹药）。
*   **结构**:
    *   `src/`: 测试执行、场景生成 (LLM)、配置加载等上层逻辑。
    *   `Code/GameStateChecker/`: 底层的游戏状态检测逻辑（视觉处理、模板匹配、OCR）。
    *   `config.yaml`: 全局配置和 GameStateChecker 的特定配置。
    *   `Code/GameStateChecker/templates/`: 存放用于模板匹配的图像。
    *   `Code/GameStateChecker/*.png`: 存放用于测试的各种游戏状态截图。
*   **核心流程 (弹药测试)**:
    1.  测试执行器 (`AmmoTestRunner`) 根据场景步骤模拟弹药变化。
    2.  加载对应弹药数量的预存截图 (`screenShot_*.png`)。
    3.  调用 `LogicLayer.check_ammo_state`。
    4.  `LogicLayer` 优先使用 `AmmoTemplateRecognizer` 进行模板匹配。
    5.  如果模板匹配失败，则提取 ROI，进行预处理，并使用 `pytesseract` 进行 OCR。
    6.  返回检测结果给 `AmmoTestRunner` 进行断言。
*   **测试目标**: 目前主要展示了对 "弹药" 这个目标的测试实现。`LogicLayer` 的 `__init__` 和配置结构表明，它可以扩展支持不同的测试目标 (`target_name`) 和不同的游戏（通过配置不同的 `targets`）。每个目标可以有自己特定的截图路径、模板和视觉参数 (`cv_params`)。

希望这个详细说明对你理解项目框架、测试目标使用方法和检测逻辑有所帮助！

---

